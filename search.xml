<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker</title>
    <url>/2023/05/28/14-22-46/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><span id="more"></span>


<p>Docker是一个开源的引用容器引擎</p>
<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>Docker可以运行在mac、windows、centos、等操作系统中，这里以centos为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1、yum包更新到最新</span><br><span class="line">yum update</span><br><span class="line">#2、安装需要的软件包，yum-util提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">#3、设置yum源</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">#4、安装docker，出现输入的界面都按y</span><br><span class="line">yum install -y docker -ce</span><br><span class="line">#5、查看docker版本，验证是否安装成功</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="配置Docker镜像加速器"><a href="#配置Docker镜像加速器" class="headerlink" title="配置Docker镜像加速器"></a>配置Docker镜像加速器</h2><p>默认情况下将从dockerhub（<a href="https://hub.docker.com）上下载docker镜像，太慢。一般都会配置镜像加速器：">https://hub.docker.com）上下载docker镜像，太慢。一般都会配置镜像加速器：</a></p>
<ul>
<li><p>USTC：中科大镜像加速器</p>
</li>
<li><p>阿里云</p>
</li>
<li><p>网易云</p>
</li>
<li><p>腾讯云</p>
<p>在阿里云控制台找镜像配置文件</p>
</li>
</ul>
<h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><h3 id="Docker服务相关命令"><a href="#Docker服务相关命令" class="headerlink" title="Docker服务相关命令"></a>Docker服务相关命令</h3><ul>
<li><p>启动docker服务		   systemctl start docker</p>
</li>
<li><p>停止docker服务           systemctl stop docker</p>
</li>
<li><p>重启docker服务           systemctl restart docker</p>
</li>
<li><p>查看docker服务状态  systemctl status  docker</p>
</li>
<li><p>开机启动kocker服务   systemctl enable docker</p>
</li>
</ul>
<h3 id="Docker镜像相关命令"><a href="#Docker镜像相关命令" class="headerlink" title="Docker镜像相关命令"></a>Docker镜像相关命令</h3><ul>
<li><p>查看镜像     docker images</p>
</li>
<li><p>搜索镜像     docker search redis</p>
</li>
<li><p>拉取镜像     docker pull redis:版本号  冒号后面为版本号不写默认官方</p>
</li>
<li><p>删除镜像     docker rmi  id    id为查看镜像中的id，也可以通过名字：版本来删</p>
</li>
<li><p>删除所有镜像  docker rmi <code>docker images -q</code></p>
</li>
</ul>
<h3 id="Docker容器相关命令"><a href="#Docker容器相关命令" class="headerlink" title="Docker容器相关命令"></a>Docker容器相关命令</h3><ul>
<li><p>查看容器            docker ps  -a</p>
<p>-a：查看所有容器  不屑就只看正在运行的容器</p>
</li>
<li><p>创建容器            docker run -it –name &#x3D; c1  &#x2F;bin&#x2F;bash</p>
<p>-i：一直运行  -t：给容器分配伪终端来可以输入命令  –name&#x3D;名字  -d:后端创建容器（不直接进入容器，需要命令来进入容器）</p>
</li>
<li><p>进入容器            docker exec -it c2   &#x2F;bin&#x2F;bash</p>
</li>
<li><p>启动容器            docker start c2</p>
</li>
<li><p>停止容器             docker stop c2</p>
</li>
<li><p>删除容器             docker rm  c1</p>
</li>
<li><p>查看容器信息    docker inspect</p>
</li>
</ul>
<h2 id="Docker容器的数据卷"><a href="#Docker容器的数据卷" class="headerlink" title="Docker容器的数据卷"></a>Docker容器的数据卷</h2><p>数据卷：数据卷是宿主机中的一个目录或文，当容器目录和数据卷的目录绑定后，对方的修改会立即同步，一个数据卷可以被多个容器同时挂载，一个容器也可以被挂在多个数据卷</p>
<h3 id="配饰数据卷"><a href="#配饰数据卷" class="headerlink" title="配饰数据卷"></a>配饰数据卷</h3><ul>
<li><p>创建启动容器时，使用-v参数设置数据卷</p>
<p>docker run    -v 宿主机目录: 容器内目录</p>
<p>tip:目录必须是绝对路径，如果目录不存在，会自动创建，可以挂在多个数据卷</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Java</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装Redis</title>
    <url>/2023/05/29/15-32-46/</url>
    <content><![CDATA[<h1 id="Linux下安装Redis"><a href="#Linux下安装Redis" class="headerlink" title="Linux下安装Redis"></a>Linux下安装Redis</h1><h2 id="1、下载Redis安装包"><a href="#1、下载Redis安装包" class="headerlink" title="1、下载Redis安装包"></a>1、下载Redis安装包</h2><p><strong>下载链接：<a href="https://redis.io/download/">下载 |雷迪斯 (redis.io)</a></strong></p>
<span id="more"></span>

<p>选择下载的版本，这里以最新版为例。默认下载就是linux下的安装包。</p>
<img src="/2023/05/29/15-32-46/redis.png" style="zoom:25%;">

<h2 id="2、上传到linux下"><a href="#2、上传到linux下" class="headerlink" title="2、上传到linux下"></a>2、上传到linux下</h2><p>上传到linux下的usr&#x2F;local&#x2F;bin目录。这里使用FinalShell，直接从本地文件拖到目录下即可。</p>
<img src="/2023/05/29/15-32-46/redis2.png" style="zoom:45%;">

<h2 id="3、解压Redis"><a href="#3、解压Redis" class="headerlink" title="3、解压Redis"></a>3、解压Redis</h2><p>执行命令<code>tar -zxvf redis-7.0.11.tar.gz</code></p>
<h2 id="4、安装环境依赖"><a href="#4、安装环境依赖" class="headerlink" title="4、安装环境依赖"></a>4、安装环境依赖</h2><p>因为redis需要c++的依赖支持，所以先安装依赖。</p>
<p>在&#x2F;usr&#x2F;local&#x2F;bin目录下执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装依赖</span></span><br><span class="line">yum install gcc-c++</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看依赖安装是否成功gcc-v 最后一行出现gcc版本号即是安装成功</span></span><br><span class="line">gcc -v</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置所有文件</span></span><br><span class="line">make</span><br><span class="line">make PREFIX=/usr/local/bin install</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5、启动redis"><a href="#5、启动redis" class="headerlink" title="5、启动redis"></a>5、启动redis</h2><p>进入redis目录下的src下执行命令<code>redis-server</code>即可启动Redis。</p>
<h2 id="6、设置密码"><a href="#6、设置密码" class="headerlink" title="6、设置密码"></a>6、设置密码</h2><p>修改Redis目录下的redis.conf文件<code>ctrl+f</code>查找requirepass。</p>
<p>将requirepass取消注释，设置自己的密码，比如<code>requirepass  root</code></p>
<h2 id="7、设置后台启动"><a href="#7、设置后台启动" class="headerlink" title="7、设置后台启动"></a>7、设置后台启动</h2><p>修改Redis目录下的redis.conf文件ctrl+f查找daemonize。</p>
<p>将<code>daemonize no</code> 改为<code>daemonize yes</code></p>
<h2 id="8、根据配置文件启动Redis"><a href="#8、根据配置文件启动Redis" class="headerlink" title="8、根据配置文件启动Redis"></a>8、根据配置文件启动Redis</h2><p>定位到Redis目录下的src目录下,执行<code>redis-server ../redis.conf</code></p>
<h2 id="9、启动redis-cli"><a href="#9、启动redis-cli" class="headerlink" title="9、启动redis.cli"></a>9、启动redis.cli</h2><p>定位到Redis目录下的src目录下,执行<code>redis-cli</code></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>InterView</title>
    <url>/2023/05/28/14-22-46/</url>
    <content><![CDATA[<h1 id="Java面试题整理"><a href="#Java面试题整理" class="headerlink" title="Java面试题整理"></a>Java面试题整理</h1><span id="more"></span>

<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="1、Java-中有哪-8-种基本数据类型？它们的默认值和占⽤的空间⼤⼩知道不？-说说这-8-种基本数据类型对应-的包装类型。"><a href="#1、Java-中有哪-8-种基本数据类型？它们的默认值和占⽤的空间⼤⼩知道不？-说说这-8-种基本数据类型对应-的包装类型。" class="headerlink" title="1、Java 中有哪 8 种基本数据类型？它们的默认值和占⽤的空间⼤⼩知道不？ 说说这 8 种基本数据类型对应 的包装类型。"></a>1、Java 中有哪 8 种基本数据类型？它们的默认值和占⽤的空间⼤⼩知道不？ 说说这 8 种基本数据类型对应 的包装类型。</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 6种基本类型：byte、short、int、long、double、float</span><br><span class="line"><span class="bullet">*</span> 1种布尔类型：boolean</span><br><span class="line"><span class="bullet">*</span> 1种字符类型：char</span><br><span class="line">** 包装类</span><br><span class="line">byte : Byte</span><br><span class="line">int : Integer</span><br><span class="line">short : Short</span><br><span class="line">long : Long</span><br><span class="line">float : Float</span><br><span class="line">double : Double</span><br><span class="line">char : Charater</span><br><span class="line">boolean : Boolean</span><br><span class="line">** 默认值</span><br><span class="line">byte = 0</span><br><span class="line">short = 0</span><br><span class="line">int = 0</span><br><span class="line">lang = 0L</span><br><span class="line">float = 0.0f</span><br><span class="line">double = 0.0d</span><br><span class="line">boolean = false</span><br><span class="line">char = null</span><br><span class="line">** 空间大小</span><br><span class="line">byte : 1</span><br><span class="line">short : 2</span><br><span class="line">int : 4</span><br><span class="line">lang : 8</span><br><span class="line">float : 4</span><br><span class="line">double :8</span><br><span class="line">char : 2</span><br></pre></td></tr></table></figure>

<h2 id="2、包装类型的常量池技术了解么？"><a href="#2、包装类型的常量池技术了解么？" class="headerlink" title="2、包装类型的常量池技术了解么？"></a>2、包装类型的常量池技术了解么？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Java中基本数据类型的包装类大多数都实现了常量池技术。比如byte、short、int、lang都默认创建了[-128,127]之间的缓存数据，超出范围会创建新的对象，float和double并没有实现常量池技术，char默认创建了[0,127]之间的数据。</span><br></pre></td></tr></table></figure>

<h2 id="3、为什么要有包装类型？"><a href="#3、为什么要有包装类型？" class="headerlink" title="3、为什么要有包装类型？"></a>3、为什么要有包装类型？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 包装类中有很多实用的方法</span><br><span class="line"><span class="bullet">-</span> 基本数据类型不能赋null值，而有时候需要</span><br><span class="line"><span class="bullet">-</span> 基本数据类型不支持泛型</span><br></pre></td></tr></table></figure>

<h2 id="4、什么是⾃动拆装箱？原理？"><a href="#4、什么是⾃动拆装箱？原理？" class="headerlink" title="4、什么是⾃动拆装箱？原理？"></a>4、什么是⾃动拆装箱？原理？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 自动拆装箱</span><br><span class="line"><span class="bullet">-</span> 自动装箱：基本数据类型向包装数据类型转换的过程，称为自动装箱</span><br><span class="line"><span class="bullet">-</span> 自动拆箱：包装数据类型向基本数据类型转换的过程，称为自动拆箱</span><br><span class="line"></span><br><span class="line">** 原理</span><br><span class="line"><span class="bullet">-</span> 自动装箱：调用包装类的valueof()方法并将要转换的数据当参数传入</span><br><span class="line"><span class="bullet">-</span> 自动拆箱：包装类型数据调用xxvalue()方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5、遇到过⾃动拆箱引发的-NPE-问题吗？"><a href="#5、遇到过⾃动拆箱引发的-NPE-问题吗？" class="headerlink" title="5、遇到过⾃动拆箱引发的 NPE 问题吗？"></a>5、遇到过⾃动拆箱引发的 NPE 问题吗？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">NPE = NullPointException</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 数据库值为null，查询时用基本数据类型来接收null值，就会报NPE异常</span><br></pre></td></tr></table></figure>

<h2 id="6、String-、-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#6、String-、-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="6、String 、 StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a>6、String 、 StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 区别</span><br><span class="line">String：是不可变的，线程不安全</span><br><span class="line">StringBuffer：线程安全(所有方法都用synchronized修饰)，效率相比StringBuilder较差</span><br><span class="line">StringBuilder：线程不安全，效率比StringBuffer好</span><br><span class="line"></span><br><span class="line">** String为什么是不可变的</span><br><span class="line">因为String底层的字符数组被final关键字修饰，所以每次对String类型的变量赋值，都会新创建一个String对象</span><br></pre></td></tr></table></figure>

<h2 id="7、重载和重写的区别？"><a href="#7、重载和重写的区别？" class="headerlink" title="7、重载和重写的区别？"></a>7、重载和重写的区别？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 区别</span><br><span class="line">应用范围：重载实现与一个类中，重写实现于子类中。</span><br><span class="line">参数列表：重载参数列表参数类型不同，重写参数列表相同。</span><br><span class="line">返回值类型：重载返回值类型可以不同，重写返回值类型必须等于父类返回值类型</span><br><span class="line">访问修饰符：重载的访问修饰符可以不同，重写的访问修饰符必须大于父类的方位修饰符			                         (public&gt;protected&gt;default&gt;private)</span><br><span class="line">异常：重载可以抛出不同的异常，重写必须抛出比父类小的异常。</span><br><span class="line">发生阶段：重载发生于编译阶段，重写发生于运行时阶段</span><br></pre></td></tr></table></figure>

<h2 id="8、-x3D-x3D-和-equals-的区别"><a href="#8、-x3D-x3D-和-equals-的区别" class="headerlink" title="8、&#x3D;&#x3D; 和 equals() 的区别"></a>8、&#x3D;&#x3D; 和 equals() 的区别</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 基本数据类型</span><br><span class="line">==比较的是值，equals比较的也是值</span><br><span class="line"></span><br><span class="line">** 引用数据类型</span><br><span class="line"><span class="bullet">-</span> 类重写了equals方法：==比较的是地址，equals比较的是值，</span><br><span class="line"><span class="bullet">-</span> 类没有重写equals方法： ==比较的是地址，equals比较的也是地址，默认调用的object的equals方法</span><br></pre></td></tr></table></figure>

<h2 id="9、Java-反射？反射有什么优点-x2F-缺点？你是怎么理解反射的（为什么框架需要反射）？"><a href="#9、Java-反射？反射有什么优点-x2F-缺点？你是怎么理解反射的（为什么框架需要反射）？" class="headerlink" title="9、Java 反射？反射有什么优点&#x2F;缺点？你是怎么理解反射的（为什么框架需要反射）？"></a>9、Java 反射？反射有什么优点&#x2F;缺点？你是怎么理解反射的（为什么框架需要反射）？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** Java反射</span><br><span class="line">在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。</span><br><span class="line"></span><br><span class="line">** 优点</span><br><span class="line"><span class="bullet">-</span> 反射机制极大的提高了程序的灵活性和扩展性，降低了模块的耦合</span><br><span class="line"><span class="bullet">-</span> 通过反射机制可以让程序创建和控制任何类的对象，无需提前硬编码目标类</span><br><span class="line"></span><br><span class="line">** 缺点</span><br><span class="line"><span class="bullet">-</span> 性能问题：Java反射机制中包含了一些动态类型，所以java虚拟机不能够对这些动态代码进行优化。</span><br><span class="line"><span class="bullet">-</span> 安全限制：实用反射通常需要程序的运行没有安全方面的限制，如果程序对安全性提出要求，则最好不要使用反射。</span><br><span class="line"></span><br><span class="line">** 框架为什么需要反射？</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="10、谈谈对-Java-注解的理解，解决了什么问题？"><a href="#10、谈谈对-Java-注解的理解，解决了什么问题？" class="headerlink" title="10、谈谈对 Java 注解的理解，解决了什么问题？"></a>10、谈谈对 Java 注解的理解，解决了什么问题？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 个人理解是用来标记程序的，这些标记在类加载、编译、运行时会被读取，并做出响应的处理。注解本身其实也是一种配置，在传统开发中我们会通过大量的配置文件比如xml、yml文件来配置我们的程序，当配置量太大时，代码的可读性就会很差。通过注解，我们就可以很方便的给程序打上标签，清晰的表明他是干嘛用的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="11、Java-泛型了解么？泛型的作⽤？什么是类型擦除？泛型有哪些限制？介绍⼀下常⽤的通配符？"><a href="#11、Java-泛型了解么？泛型的作⽤？什么是类型擦除？泛型有哪些限制？介绍⼀下常⽤的通配符？" class="headerlink" title="11、Java 泛型了解么？泛型的作⽤？什么是类型擦除？泛型有哪些限制？介绍⼀下常⽤的通配符？"></a>11、Java 泛型了解么？泛型的作⽤？什么是类型擦除？泛型有哪些限制？介绍⼀下常⽤的通配符？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 泛型</span><br><span class="line">顾名思义，泛型就是广泛的类型，也就是说什么类型都可以。</span><br><span class="line"></span><br><span class="line">** 泛型的作用</span><br><span class="line">-- 类型安全：泛型的主要目标就是提升java程序的类型安全。</span><br><span class="line">-- 消除强制类型转换：泛型附带的好处就是，消除了源代码中许多的强制类型转换。这使得代码的可读性更好，并且减少了出错的机会</span><br><span class="line"></span><br><span class="line">** 什么是类型擦除？</span><br><span class="line">java的泛型是伪泛型，因为java在编译期间会将所有的泛型信息擦掉。java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码文件中是不会包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程称为泛型擦除。</span><br><span class="line"></span><br><span class="line">** 泛型有那些限制</span><br><span class="line"><span class="bullet">-</span> 泛型不能用于基本数据类型</span><br><span class="line"><span class="bullet">-</span> java泛型不允许实例化</span><br><span class="line"><span class="bullet">-</span> java泛型不允许静态化</span><br><span class="line"><span class="bullet">-</span> java泛型不允许直接进行类型转换（通配符可以）</span><br><span class="line"><span class="bullet">-</span> java泛型不允许直接使用instanceof运算符进行运行时类型检查（通配符可以）</span><br><span class="line"><span class="bullet">-</span> java泛型不允许创建确切的泛型数组（通配符可以）</span><br><span class="line"><span class="bullet">-</span> java泛型不允许创建泛型异常类或者catch异常</span><br><span class="line"><span class="bullet">-</span> java泛型不允许作为参数重载</span><br><span class="line"></span><br><span class="line">** 泛型常见通配符</span><br><span class="line"><span class="bullet">-</span> T、E、K、V、？</span><br><span class="line"><span class="bullet">-</span> &lt; ? extends E &gt; 上界通配符</span><br><span class="line"><span class="bullet">-</span> &lt; ? super E &gt; 下界通配符</span><br></pre></td></tr></table></figure>

<h2 id="12、内部类了解吗？匿名内部类了解吗？"><a href="#12、内部类了解吗？匿名内部类了解吗？" class="headerlink" title="12、内部类了解吗？匿名内部类了解吗？"></a>12、内部类了解吗？匿名内部类了解吗？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 内部类</span><br><span class="line"><span class="bullet">-</span> 静态内部类：</span><br><span class="line"><span class="bullet">-</span> 非静态内部类：</span><br><span class="line"><span class="bullet">-</span> 局部内部类：</span><br><span class="line"><span class="bullet">-</span> 匿名内部类：匿名内部类是一种没有类名的内部类，不能用关键字class、extends、implements，没有构造函数，它必须继承其他类或实现其他接口。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="13、BIO-NIO-AIO-有什么区别"><a href="#13、BIO-NIO-AIO-有什么区别" class="headerlink" title="13、BIO,NIO,AIO 有什么区别?"></a>13、BIO,NIO,AIO 有什么区别?</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** BIO（Blocking  I/O）</span><br><span class="line">Bio属于同步阻塞IO模型，应用程序发起read调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</span><br><span class="line">在客户端连接数量不高的情况下是没问题的，但是当十万甚至百万级别连接的时候，传统的BIO模型是无能为力的。因此我们需要一种更高效的I/O处理模型来应对更高的并发量。</span><br><span class="line"></span><br><span class="line">** NIO（Non Blocking I/O）</span><br><span class="line">Java中的NIO可以看作是I/O多路复用模型。也有很多人认为，jva中的NIO属于同步非阻塞IO模型。</span><br><span class="line"><span class="strong">*** 同步非阻塞Io</span></span><br><span class="line"><span class="strong">同步非阻塞IO模型中，应用程序会一直发起read调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</span></span><br><span class="line"><span class="strong">相比于同步阻塞IO模型，同步非阻塞Io模型确实有了很大的改进。通过轮询操作，避免了一直阻塞</span></span><br><span class="line"><span class="strong">但是应用程序不断进行I/O系统调用轮询数据是否已经准备好的过程是十分消耗CPU资源的。·1</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">**</span>* I/O多路复用模型</span><br><span class="line">IO多路复用模型中，线程首先发起select调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起read调用。read调用的过程还是阻塞的。</span><br><span class="line">IO多路复用模型，通过减少无效的系统调用，减少了对CPU资源的消耗。</span><br><span class="line"></span><br><span class="line">** AIO（Asynchronous I/O）</span><br><span class="line">AIO也就是NIO2，Java7中心如了NIO的改进版NIO2，他是异步IO模型。</span><br><span class="line">异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞在哪里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</span><br></pre></td></tr></table></figure>

<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h2 id="1、说说List、Set、Map三者的区别"><a href="#1、说说List、Set、Map三者的区别" class="headerlink" title="1、说说List、Set、Map三者的区别"></a>1、说说List、Set、Map三者的区别</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** </span><br><span class="line">List：元素有序，可重复</span><br><span class="line">Set：元素无序，不可重复</span><br><span class="line">Map：存储键值对，map中的key是无序不可重复的，value是无序可重复的。</span><br></pre></td></tr></table></figure>

<h2 id="2、List-Set-Map-在-Java-中分别由哪些对应的实现类？底层的数据结构？"><a href="#2、List-Set-Map-在-Java-中分别由哪些对应的实现类？底层的数据结构？" class="headerlink" title="2、List , Set , Map 在 Java 中分别由哪些对应的实现类？底层的数据结构？"></a>2、List , Set , Map 在 Java 中分别由哪些对应的实现类？底层的数据结构？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** List</span><br><span class="line">ArrayList：底层是Object数组</span><br><span class="line">Vector：底层是Object数组</span><br><span class="line">LinkedList：底层是双向链表</span><br></pre></td></tr></table></figure>

<h2 id="3、有哪些集合是线程不安全的？怎么解决呢？"><a href="#3、有哪些集合是线程不安全的？怎么解决呢？" class="headerlink" title="3、有哪些集合是线程不安全的？怎么解决呢？"></a>3、有哪些集合是线程不安全的？怎么解决呢？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** List</span><br><span class="line">ArrayList、LinkedList</span><br><span class="line">解决方式：Collections.synchronizedList()转换成线程安全的集合，或者使用CopyOnWriteArrayList集合代替</span><br><span class="line"></span><br><span class="line">** Set</span><br><span class="line">HashSet、TreeSet、LinkedHashSet</span><br><span class="line">解决方式：Collections.synchronizedSet()转换成线程安全的集合，或使用CopyOnWriteArraySet集合代替</span><br><span class="line"></span><br><span class="line">** Map</span><br><span class="line">HashMap、LinkedHashMap、TreeMap</span><br><span class="line">解决方式：Collections.synchronizedMap()转换成线程安全的集合，或使用ConcurrentHashMap集合代替</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4、HashMap-查询，删除的时间复杂度"><a href="#4、HashMap-查询，删除的时间复杂度" class="headerlink" title="4、HashMap 查询，删除的时间复杂度"></a>4、HashMap 查询，删除的时间复杂度</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 查询</span><br><span class="line">hashMap的底层实现是由数组+链表+红黑树组成。</span><br><span class="line">不管是查找还是插入，hashmap定位到桶的事件复杂度都是O(1),那么真正决定事件复杂度的实际上是桶里面的链表/红黑树，当桶里没数据事件复杂度是O(1),当桶里面是链表时间复杂度是O(n)，链表越长时间复杂度越长，当桶里面是红黑树时，时间复杂度是O(logn)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5、HashMap-的底层实现"><a href="#5、HashMap-的底层实现" class="headerlink" title="5、HashMap 的底层实现"></a>5、HashMap 的底层实现</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** JDK1.8之前</span><br><span class="line">数组+链表</span><br><span class="line">数组是数据的主要载体，链表主要是为了解决hash冲突</span><br><span class="line"></span><br><span class="line">** JDK1.8之后</span><br><span class="line">数组+链表+红黑树</span><br><span class="line">当单列表的长度达到8的时候会进化成红黑树</span><br></pre></td></tr></table></figure>

<h2 id="6、HashMap-的⻓度为什么是-2-的幂次⽅"><a href="#6、HashMap-的⻓度为什么是-2-的幂次⽅" class="headerlink" title="6、HashMap 的⻓度为什么是 2 的幂次⽅"></a>6、HashMap 的⻓度为什么是 2 的幂次⽅</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">因为hahsMap的length等于2的n次方的时候，才会有hash%length==hash&amp;(length-1)；哈希算法的目的是为了加快哈希计算以及减少哈希冲突，所以此时&amp;操作更合适，所以在length等于2的幂次方的时候，可以使用&amp;操作加快操作且减少冲突，所以hashMap长度是2的幂次方</span><br></pre></td></tr></table></figure>

<h2 id="7、⽐较-HashSet-、-LinkedHashSet-和-TreeSet-三者的异同"><a href="#7、⽐较-HashSet-、-LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="7、⽐较 HashSet 、 LinkedHashSet 和 TreeSet 三者的异同"></a>7、⽐较 HashSet 、 LinkedHashSet 和 TreeSet 三者的异同</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 同</span><br><span class="line">HashSet、LinkedHashSet、TreeSet都是Set接口的实现类，都能保证元素唯一性，且都不是线程安全的。</span><br><span class="line"></span><br><span class="line">** 异</span><br><span class="line">HashSet、LinkedHashSet、TreeSet的主要区别是底层数据结构的不同</span><br><span class="line">HashSet底层是hash表，基于HashMap实现。</span><br><span class="line">LinkedHashMap的底层是链表和hash表，元素的插入和取出满足先进先出。</span><br><span class="line">TreeSet底层是红黑树，元素是有序的，排序方式有自然排序和定制排序</span><br><span class="line"></span><br><span class="line">三者底层数据结构的不同又导致三者的应用场景的不同， HashSet用于不需要保证元素插入和取出的顺序的场景。LinkedHashSet用于保证元素的插入和取出先进先出的场景。TreeSet集合用于支持元素自定义排序的场景。</span><br></pre></td></tr></table></figure>

<h2 id="8、HashMap-和-Hashtable-的区别？"><a href="#8、HashMap-和-Hashtable-的区别？" class="headerlink" title="8、HashMap 和 Hashtable 的区别？"></a>8、HashMap 和 Hashtable 的区别？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** </span><br><span class="line"><span class="bullet">-</span> 继承的父类不同：HashMap继承AbsractMap类。HashTable继承Dictionary类，不过Dictionary类已经废弃。</span><br><span class="line"><span class="bullet">-</span> 线程安全性不同：HashMap线程不安全，HashTable线程安全。</span><br><span class="line"><span class="bullet">-</span> 是否允许null值：HashMap允许允许key和value为null，hashTabl的key和value都不允许为null</span><br><span class="line"><span class="bullet">-</span> 扩容方式不同：HashMap每次扩容2的幂次方倍，HashTable每次扩容2背加1</span><br><span class="line"><span class="bullet">-</span> 底层数据结构：1.8以前都是数组加链表，1.8以后hashmap引入了红黑树</span><br><span class="line"><span class="bullet">-</span> 初始化容量不同：hashMap初始化容量为16，hashTable初始化容量为11</span><br></pre></td></tr></table></figure>

<h2 id="9、HashMap-和-HashSet-区别？"><a href="#9、HashMap-和-HashSet-区别？" class="headerlink" title="9、HashMap 和 HashSet 区别？"></a>9、HashMap 和 HashSet 区别？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** </span><br><span class="line"><span class="bullet">-</span> HashSet实现了Set接口，进存储对象，而HashMAp存储键值对</span><br><span class="line"><span class="bullet">-</span> hashSet实现了set接口，hashMap实现了map接口</span><br><span class="line"><span class="bullet">-</span> hashset使用成员对象来计算hshcode值，hashMap中使用键对象来计算hashcode</span><br></pre></td></tr></table></figure>

<h2 id="10、HashMap-和-TreeMap-区别？"><a href="#10、HashMap-和-TreeMap-区别？" class="headerlink" title="10、HashMap 和 TreeMap 区别？"></a>10、HashMap 和 TreeMap 区别？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** </span><br><span class="line"><span class="bullet">-</span> HashMap适用于在map中插入、删除、定位元素 TreeMap适用于自然顺序或自定义顺序排序。</span><br><span class="line"><span class="bullet">-</span> hashMap的结果是没有排序的，TreeMap输出的结果是排好序的。</span><br></pre></td></tr></table></figure>

<h2 id="11、ConcurrentHashMap-和-Hashtable-的区别？"><a href="#11、ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="11、ConcurrentHashMap 和 Hashtable 的区别？"></a>11、ConcurrentHashMap 和 Hashtable 的区别？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 底层数据结构</span><br><span class="line">ConcurrentHashMap：Jdk1.7底层采用分段的数组+链表实现，Jdk1.8采用的数据结构和HahMap的结构一样，数组+链表/红黑树</span><br><span class="line">HashTable：底层数据结构和1.8和hashMap一样，采用数组+链表的形式，数组是hashMap的主体，链表是主要为了解决hash冲突而存在的。</span><br><span class="line"></span><br><span class="line">** 实现线程安全的方式：</span><br><span class="line">-ConcurrentHashMap：1.7的时候，ConcurrentHashMap采用分段锁，对整个桶数组进行了分割分段，每个锁只所著容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。1.8的时候摒弃了分段的概念，采用数组+链表+红黑树的数据结构来实现，并发控制使用synchronized和CAS来操作。</span><br><span class="line"><span class="bullet">-</span> HashTable： 使用synchronized来保证线程安全，效率非常底下。</span><br></pre></td></tr></table></figure>

<h2 id="12、ConcurrentHashMap-线程安全的具体实现⽅式-x2F-底层具体实现"><a href="#12、ConcurrentHashMap-线程安全的具体实现⽅式-x2F-底层具体实现" class="headerlink" title="12、ConcurrentHashMap 线程安全的具体实现⽅式&#x2F;底层具体实现"></a>12、ConcurrentHashMap 线程安全的具体实现⽅式&#x2F;底层具体实现</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line">在 JDK1.7 中，ConcurrentHashMap 采用了分段锁策略，将一个 HashMap 切割成 Segment 数组，其中 Segment 可以看成一个 HashMap， 不同点是 Segment 继承自 ReentrantLock，在操作的时候给 Segment 赋予了一个对象锁，从而保证多线程环境下并发操作安全。</span><br><span class="line">在 JDK1.8 中，与此对应的 ConcurrentHashMap 也是采用了与 HashMap 类似的存储结构，但是 JDK1.8 中 ConcurrentHashMap 并没有采用分段锁的策略，而是在元素的节点上采用 CAS + synchronized 操作来保证并发的安全性，</span><br></pre></td></tr></table></figure>

<h2 id="13、HashMap-为什么线程不安全？"><a href="#13、HashMap-为什么线程不安全？" class="headerlink" title="13、HashMap 为什么线程不安全？"></a>13、HashMap 为什么线程不安全？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** </span><br><span class="line">JDK1.7 中，由于多线程对HashMap进行扩容，调用了HashMap#transfer()，具体原因：某个线程执行过程中，被挂起，其他线程已经完成数据迁移，等CPU资源释放后被挂起的线程重新执行之前的逻辑，数据已经被改变，造成死循环、数据丢失。</span><br><span class="line">JDK1.8 中，由于多线程对HashMap进行put操作，调用了HashMap#putVal()，具体原因：假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h2 id="1、什么是线程和进程-线程与进程的关系-区别及优缺点？"><a href="#1、什么是线程和进程-线程与进程的关系-区别及优缺点？" class="headerlink" title="1、什么是线程和进程?线程与进程的关系,区别及优缺点？"></a>1、什么是线程和进程?线程与进程的关系,区别及优缺点？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 进程</span><br><span class="line">进程是程序的一次执行过程， 是系统运行程序的基本单位，因此进程是动态的，系统运行一个程序就是一个进程从创建到消亡的过程。</span><br><span class="line"></span><br><span class="line">** 线程</span><br><span class="line">线程与进程相似，但线程是比进程更小的一个执行单元，一个进程在执行过程中可以产生多个线程，与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程都有自己的程序计数器、虚拟机栈和本地方法栈，，所以系统在产生一个线程或在各个线程之间切换工作时负担比进程小的多。</span><br><span class="line"></span><br><span class="line">** 关系</span><br><span class="line">一个进程可以包含多个线程。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2、为什么要使⽤多线程呢"><a href="#2、为什么要使⽤多线程呢" class="headerlink" title="2、为什么要使⽤多线程呢?"></a>2、为什么要使⽤多线程呢?</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 从计算机底层来说</span><br><span class="line">线程可以比作轻量级的进程，是程序执行的最小单元，线程之间的切换和调度成本远远小于进程。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 从当代互联网发展趋势来看</span><br><span class="line">现在系统动不动就要求百万级别的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统的并发能力和性能。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3、说说线程的⽣命周期和状态"><a href="#3、说说线程的⽣命周期和状态" class="headerlink" title="3、说说线程的⽣命周期和状态?"></a>3、说说线程的⽣命周期和状态?</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">New：初始状态，线程被创建出来但没调用start方法</span><br><span class="line">Runnable：运行状态，线程被调用了start方法等待运行</span><br><span class="line">Blocked：阻塞状态，需要等待锁释放</span><br><span class="line">Waiting：等待状态，表示该线程需要等待其他线程做出特定动作（通知或中断）</span><br><span class="line">Time-waiting:超时等待状态，可以在指定时间后自动返回，不想waiting一直等待</span><br><span class="line">Terminated：终止状态，表示该线程已经运行完毕。</span><br></pre></td></tr></table></figure>

<h2 id="4、什么是线程死锁-如何避免死锁-如何预防和避免线程死锁"><a href="#4、什么是线程死锁-如何避免死锁-如何预防和避免线程死锁" class="headerlink" title="4、什么是线程死锁?如何避免死锁?如何预防和避免线程死锁?"></a>4、什么是线程死锁?如何避免死锁?如何预防和避免线程死锁?</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 什么时线程死锁</span><br><span class="line">多个线程同时被阻塞，他们中的一个或全部都在等待某个资源被释放。由于线程被无限期阻塞，所以程序不可能正常停止。</span><br><span class="line"></span><br><span class="line">** 如何预防和避免死锁</span><br><span class="line"><span class="bullet">-</span> 破坏请求与保持条件：一次性申请所有资源</span><br><span class="line"><span class="bullet">-</span> 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</span><br><span class="line"><span class="bullet">-</span> 破坏循环等待条件：按序申请来预防，按某一顺序申请资源，释放资源则反序释放。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5、synchronized-关键字的作⽤，⾃⼰是怎么使⽤的。"><a href="#5、synchronized-关键字的作⽤，⾃⼰是怎么使⽤的。" class="headerlink" title="5、synchronized 关键字的作⽤，⾃⼰是怎么使⽤的。"></a>5、synchronized 关键字的作⽤，⾃⼰是怎么使⽤的。</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 作用</span><br><span class="line"><span class="bullet">-</span> 原子性：多个操作执行过程中，要么全部执行完成，要么就全部不执行。</span><br><span class="line"><span class="bullet">-</span> 可见性：多个线程访问一个资源时，改资源的状态信息等，对于其他线程都是		 可见的</span><br><span class="line"><span class="bullet">-</span> 有序性：是指在程序执行过程中，是有顺序的进行， synchronized保证了		  每一个时刻只有一个线程访问同步代码块，确定了线程执行同步代码		 块的顺序，保证了有序性。</span><br><span class="line"></span><br><span class="line">** 使用</span><br><span class="line"><span class="bullet">-</span> 修饰实例方法：作用于当前对象实例加锁，进入同步代码块前要获取当前对象 			   实例的锁</span><br><span class="line"><span class="bullet">-</span> 修饰静态方法：也就是给当前类加锁，会作用于类的所有对象实例，进入同步			  代码块前要获得当前class的锁。</span><br><span class="line"><span class="bullet">-</span> 修饰代码块：指定加锁对象，对给定对象/类加锁。synchronized(this)表			示进入同步代码块前要获得给定对象的锁。</span><br></pre></td></tr></table></figure>

<h2 id="6、synchronized-关键字的底层原理（重点！！！）"><a href="#6、synchronized-关键字的底层原理（重点！！！）" class="headerlink" title="6、synchronized 关键字的底层原理（重点！！！）"></a>6、synchronized 关键字的底层原理（重点！！！）</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">当一个线程要访问某个对象的synchronized方法或synchronized块时，首先会尝试获取这个对象的monitor（监视器）锁。</span><br><span class="line">如果该monitor锁没有被其他线程占用，则该线程获取该monitor锁，并且将锁计数器设置为1。</span><br><span class="line">如果该monitor锁已经被其他线程占用了，则该线程进入阻塞状态，直到该monitor锁被释放，并且重新尝试获取锁。</span><br><span class="line">当一个线程执行完该synchronized方法或synchronized块后，会释放这个monitor锁，从而使其他线程能够获取该锁。</span><br><span class="line">需要注意的是，一个对象的monitor锁只有一个，所以当多个线程同时访问该对象的synchronized方法或synchronized块时，它们实际上是在竞争同一个monitor锁。因此，使用synchronized关键字要注意锁粒度，尽量减小锁的范围，避免因为过度使用synchronized关键字导致性能问题。</span><br></pre></td></tr></table></figure>

<h2 id="7、JDK1-6-之后的-synchronized-关键字底层做了哪些优化。-synchronized-锁升级流程。"><a href="#7、JDK1-6-之后的-synchronized-关键字底层做了哪些优化。-synchronized-锁升级流程。" class="headerlink" title="7、JDK1.6 之后的 synchronized 关键字底层做了哪些优化。 synchronized 锁升级流程。"></a>7、JDK1.6 之后的 synchronized 关键字底层做了哪些优化。 synchronized 锁升级流程。</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 锁消除</span><br><span class="line">如果synchronized的内容不可能引起同步问题，则编译时忽略synchronized，变成没有锁的代码</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 锁膨胀</span><br><span class="line">在一个方法中，如果发现多个连续的加锁和解锁操作，JVM会自动将其合并为一次锁操作，减少加锁和解锁操作对性能的影响。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 锁升级</span><br><span class="line">无锁：刚开始时，对象没有锁标记，线程可以无障碍地访问该对象。</span><br><span class="line">偏向锁：当一个线程访问某个对象的同步代码块时，会自动获取偏向锁，并且将对象的标识符记录下来。在以后的访问中，如果检测到这个对象的标识符与线程的标识符相同，就可以直接访问，无需再次获取锁。这种场景适用于大多数情况下目的是读取变量值的场景。</span><br><span class="line">轻量级锁：如果多个线程一起访问同一个对象，偏向锁会失效。这时会尝试将对象的锁升级为轻量级锁。轻量级锁是由Java虚拟机实现的一种自旋锁。线程会尝试CAS操作来获取锁，如果CAS成功，则获取锁；如果CAS失败，线程会一直循环等待。</span><br><span class="line">重量级锁：当轻量级锁竞争不到锁时，锁就会升级为重量级锁。重量级锁是由操作系统实现的一种互斥锁。当线程尝试获取锁时，如果锁已经被占用，线程就会进入阻塞状态，直到获得锁为止。重量级锁的竞争开销很大，在使用时需要慎重。</span><br><span class="line"></span><br><span class="line">锁的状态从无锁状态开始，升级为偏向锁，再升级为轻量级锁，最后升级为重量级锁。偏向锁是为了降低无竞争情况下竞争产生的开销；轻量级锁是针对锁竞争比较轻的情况下所引入的优化机制，避免线程一直阻塞等待锁；重量级锁是在多个线程竞争同一个锁时，无法避免的机制。在实际使用过程中，synchronized锁的优化机制会根据锁使用的情况进行自动切换，以达到最优的性能表现。</span><br></pre></td></tr></table></figure>

<h2 id="8、synchronized-和-ReentrantLock-的区别。"><a href="#8、synchronized-和-ReentrantLock-的区别。" class="headerlink" title="8、synchronized 和 ReentrantLock 的区别。"></a>8、synchronized 和 ReentrantLock 的区别。</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 用法不同</span><br><span class="line"><span class="bullet">-</span> synchronized可以用来修饰普通方法，静态方法和代码块</span><br><span class="line"><span class="bullet">-</span> ReentrantLock只能用于代码块</span><br><span class="line"></span><br><span class="line">** 获取锁和释放锁的机制不同</span><br><span class="line"><span class="bullet">-</span> synchronized是自动加锁和释放锁的</span><br><span class="line"><span class="bullet">-</span> ReentrantLock是手动加锁和释放锁</span><br><span class="line"></span><br><span class="line">** 锁类型不同</span><br><span class="line"><span class="bullet">-</span> synchronized是非公平锁</span><br><span class="line"><span class="bullet">-</span> ReentrantLock既可以是非公平锁，也可以是公平锁</span><br><span class="line"></span><br><span class="line">** 响应中断不同：</span><br><span class="line"><span class="bullet">-</span> synchronized不可以响应终端</span><br><span class="line"><span class="bullet">-</span> ReetrantLock可以响应中断，解决死锁问题</span><br><span class="line"></span><br><span class="line">** 底层实现不同</span><br><span class="line"><span class="bullet">-</span> synchronized是jvm层面通过监视器实现的</span><br><span class="line"><span class="bullet">-</span> ReentrantLock是基于AQS实现的</span><br></pre></td></tr></table></figure>

<h2 id="9、synchronized-和-volatile-的区别。"><a href="#9、synchronized-和-volatile-的区别。" class="headerlink" title="9、synchronized 和 volatile 的区别。"></a>9、synchronized 和 volatile 的区别。</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 作用范围</span><br><span class="line"><span class="bullet">-</span> synchronized可以用于方法、代码块等</span><br><span class="line"><span class="bullet">-</span> volatile通常用于修饰变量</span><br><span class="line"></span><br><span class="line">** 锁类型</span><br><span class="line"><span class="bullet">-</span> synchronized使用的是排他锁，即一个线程获得了锁，其他线程必须等待该线程释放锁才能访问</span><br><span class="line"><span class="bullet">-</span> volatile是一种轻量级的锁不会引起线程阻塞，也不需要获取和释放锁</span><br><span class="line"></span><br><span class="line">** 线程安全</span><br><span class="line"><span class="bullet">-</span> synchronized可以保证一段代码的原子性和线程安全性</span><br><span class="line"><span class="bullet">-</span> volatile只能保证局部变量的可见性</span><br></pre></td></tr></table></figure>

<h2 id="10、并发编程的三个重要特性"><a href="#10、并发编程的三个重要特性" class="headerlink" title="10、并发编程的三个重要特性"></a>10、并发编程的三个重要特性</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 原子性</span><br><span class="line"><span class="bullet">-</span> 可见性</span><br><span class="line"><span class="bullet">-</span> 有序性</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="11、JMM-（Java-Memory-Model，Java-内存模型）和-happens-before-原则"><a href="#11、JMM-（Java-Memory-Model，Java-内存模型）和-happens-before-原则" class="headerlink" title="11、JMM （Java Memory Model，Java 内存模型）和 happens-before 原则"></a>11、JMM （Java Memory Model，Java 内存模型）和 happens-before 原则</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="12、ThreadLocal是什么？"><a href="#12、ThreadLocal是什么？" class="headerlink" title="12、ThreadLocal是什么？"></a>12、ThreadLocal是什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThreadLocal，即线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是在操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了并发场景下的线程安全问题。</span><br></pre></td></tr></table></figure>

<h2 id="13、为什么要使用ThreadLocal"><a href="#13、为什么要使用ThreadLocal" class="headerlink" title="13、为什么要使用ThreadLocal"></a>13、为什么要使用ThreadLocal</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">并发场景下，会存在多个线程同时修改一个共享变量的场景，这就可能会出现安全问题。</span><br><span class="line"></span><br><span class="line">解决方式有两种，第一种是使用synchronized或者Lock加锁，但是加锁的方式，会导致系统变慢。第二种就是空间换时间的方式，即使用ThreadLocal。使用ThreadLocal访问共享变量时，会在每个线程的本地，都保存一份共享变量的拷贝副本。多线程对共享变量修改时，实际上操作的是这个变量副本，从而保证线性安全。</span><br></pre></td></tr></table></figure>

<h2 id="14、ThreadLocal的实现原理"><a href="#14、ThreadLocal的实现原理" class="headerlink" title="14、ThreadLocal的实现原理"></a>14、ThreadLocal的实现原理</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> ThreadLocal线程类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，即每个线程都有一个属于自己的ThreadLocalMap</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> ThreadLocalMap内部维护者Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal本身，value是ThreadLocal的泛型值。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 并发多线程场景下，每个线程Thread在往ThreaLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以ThreadLocal作为引用，在自己的map里找对应的key，从而可以实现了线程隔离。</span><br></pre></td></tr></table></figure>

<h2 id="15、ThreadLocal的内存泄露"><a href="#15、ThreadLocal的内存泄露" class="headerlink" title="15、ThreadLocal的内存泄露"></a>15、ThreadLocal的内存泄露</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap使用ThreadLocal的弱引用作为key，当ThreadLocal变量被手动设置为null，即一个ThreadLcoal没有外部强引用来引用他，当系统GC时，ThreadLocal一定会被回收，这样的话，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链，永远无法回收，造成内存泄露。</span><br></pre></td></tr></table></figure>



<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="1、如何定位慢查询"><a href="#1、如何定位慢查询" class="headerlink" title="1、如何定位慢查询"></a>1、如何定位慢查询</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">在mysql配置文件中开启慢查询日志，我们设置的值为2秒，一旦sql执行超过两秒就会记录到日志中。</span><br><span class="line"></span><br><span class="line">聚合查询、多表查询、表数据量过大查询、深度分页查询都会造成慢查询</span><br><span class="line"></span><br><span class="line">slow-query-log =1 </span><br><span class="line">long-query-time=2</span><br></pre></td></tr></table></figure>

<h2 id="2、sql语句执行慢如何优化？"><a href="#2、sql语句执行慢如何优化？" class="headerlink" title="2、sql语句执行慢如何优化？"></a>2、sql语句执行慢如何优化？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">如果一条sql执行很慢，我们通常使用mysql的自动执行计划explain来查看这条sql的执行情况，比如在这里面我们可以通过key、key<span class="emphasis">_len检查是否命中了索引，如果本身有索引也可以判断索引是否有失效的情况。第二可以从type字段查看sql是否有优化空间，是否存在全索引扫描或者全盘扫描。第三个可以通过xetra建议来判断，是否出现了回表的情况，如果出现了可以通过添加索引或修改返回字段来修复。</span></span><br></pre></td></tr></table></figure>

<h2 id="3、什么是索引？"><a href="#3、什么是索引？" class="headerlink" title="3、什么是索引？"></a>3、什么是索引？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 索引是帮助mysql高效获取数据的数据结构</span><br><span class="line"><span class="bullet">-</span> 提高数据的检索效率，减少数据库的io成本</span><br><span class="line"><span class="bullet">-</span> 通过索引列对数据进行排序，降低了数据库排序的成本，降低了cpu的消耗</span><br></pre></td></tr></table></figure>

<h2 id="4、索引底层的数据结构了解吗？"><a href="#4、索引底层的数据结构了解吗？" class="headerlink" title="4、索引底层的数据结构了解吗？"></a>4、索引底层的数据结构了解吗？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Mysql的InnoDB引擎采用的是B+树的数据结构来存储索引。</span><br><span class="line">相比B树</span><br><span class="line"><span class="bullet">-</span> 阶数更多，路径更短</span><br><span class="line"><span class="bullet">-</span> 磁盘读写代价更低，非叶子节点只存储指针，叶子节点才存储数据</span><br><span class="line"><span class="bullet">-</span> B+树便于扫库和区间查询，叶子节点是一个双向链表</span><br></pre></td></tr></table></figure>

<h2 id="5、什么是聚簇索引，什么是非聚簇索引？什么是回表？"><a href="#5、什么是聚簇索引，什么是非聚簇索引？什么是回表？" class="headerlink" title="5、什么是聚簇索引，什么是非聚簇索引？什么是回表？"></a>5、什么是聚簇索引，什么是非聚簇索引？什么是回表？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 聚簇索引：数据与索引存放在一起，B+树的叶子节点保存了整行数据，有且只有           一个</span><br><span class="line"><span class="bullet">-</span> 非聚簇索引：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多           个2+</span><br><span class="line"><span class="bullet">-</span> 回表：通过二级索引查询到对应的主键值，到聚簇索引中查找整行数据，这个过        程就是回表</span><br></pre></td></tr></table></figure>

<h2 id="6、"><a href="#6、" class="headerlink" title="6、"></a>6、</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">覆盖索引是指查询使用了索引，返回的列，必须在索引中全部能找到。</span><br><span class="line"><span class="bullet">-</span> 使用id查询，直接走的是聚簇索引，一次索引扫描，直接返回数据，性能高</span><br><span class="line"><span class="bullet">-</span> 如果返回的列中没有创建索引，有可能触发回表查询，尽量避免使用slect <span class="emphasis">*</span></span><br></pre></td></tr></table></figure>

<h2 id="7、索引创建的规则"><a href="#7、索引创建的规则" class="headerlink" title="7、索引创建的规则"></a>7、索引创建的规则</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 数据量大，且查询比较频繁的表  重要</span><br><span class="line"><span class="bullet">-</span> 经常作为查询条件、分组、排序的字段  重要</span><br><span class="line"><span class="bullet">-</span> 字段内容区分读高</span><br><span class="line"><span class="bullet">-</span> 内容较长，建议使用前缀索引</span><br><span class="line"><span class="bullet">-</span> 尽量使用联合索引  重要</span><br><span class="line"><span class="bullet">-</span> 要控制索引的数量  重要</span><br><span class="line"><span class="bullet">-</span> 如果索引列不能存储null值，请在创建表时使用notnull约束它。</span><br></pre></td></tr></table></figure>

<h2 id="8、什么情况下索引会失效"><a href="#8、什么情况下索引会失效" class="headerlink" title="8、什么情况下索引会失效"></a>8、什么情况下索引会失效</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 违反最左前缀法则</span><br><span class="line"><span class="bullet">-</span> 范围查询右边的列，不能使用索引</span><br><span class="line"><span class="bullet">-</span> 不要再索引上进行运算操作，索引将失效</span><br><span class="line"><span class="bullet">-</span> 字符串不加单引号，数据类型转换会导致索引失效</span><br><span class="line"><span class="bullet">-</span> 以%开头的模糊查询</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9、谈谈sql优化的经验"><a href="#9、谈谈sql优化的经验" class="headerlink" title="9、谈谈sql优化的经验"></a>9、谈谈sql优化的经验</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 表的设计优化，比如数据类型的选择</span><br><span class="line"><span class="bullet">-</span> 索引优化，索引的创建规则</span><br><span class="line"><span class="bullet">-</span> sql语句优化，比如避免索引失效、避免使用select *</span><br><span class="line"><span class="bullet">-</span> 主从赋值、读写分离</span><br><span class="line"><span class="bullet">-</span> 分库分表</span><br></pre></td></tr></table></figure>

<h2 id="10、-事务的特性是什么？可以详细说以下吗？"><a href="#10、-事务的特性是什么？可以详细说以下吗？" class="headerlink" title="10、 事务的特性是什么？可以详细说以下吗？"></a>10、 事务的特性是什么？可以详细说以下吗？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 事务</span><br><span class="line">事务是一组操作的集合，他是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，这些操作要么同时成功，要么同时失败。</span><br><span class="line"></span><br><span class="line">** 特性 ACID</span><br><span class="line"><span class="bullet">-</span> 原子性（Atomicity）：事务是不可分割的最小执行单元，同成功同失败</span><br><span class="line"><span class="bullet">-</span> 一致性（Consistency）：事务完成时，必须所有数据保持一种状态</span><br><span class="line"><span class="bullet">-</span> 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务再不受外部并					发影响的独立环境下运行。一个事务内部的操作						及使用的数据对其他事务是隔离的，并发执行的各						个事务之间不能相互干扰。</span><br><span class="line"><span class="bullet">-</span> 持久性（Durability）：事务一旦提交或回滚，它对数据库的数据的改变是					永久的</span><br></pre></td></tr></table></figure>

<h2 id="11、并发事务带来了那些问题？怎么解决这些问题？Mysql的默认隔离级别是？"><a href="#11、并发事务带来了那些问题？怎么解决这些问题？Mysql的默认隔离级别是？" class="headerlink" title="11、并发事务带来了那些问题？怎么解决这些问题？Mysql的默认隔离级别是？"></a>11、并发事务带来了那些问题？怎么解决这些问题？Mysql的默认隔离级别是？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">** 并发事务问题</span><br><span class="line"><span class="bullet">-</span> 脏读：一个事务读到另一个事务还没有提交的数据</span><br><span class="line"><span class="bullet">-</span> 不可重复读：一个事务先后读取同一个数据，但两次读取数据不同</span><br><span class="line"><span class="bullet">-</span> 幻读：一个事务在根据条件查询时，没有对应的数据，但在插入数据时，又发        现这行数据已经存在了。</span><br><span class="line"></span><br><span class="line">** 解决方案</span><br><span class="line">对事务进行隔离</span><br><span class="line">隔离级别:</span><br><span class="line"><span class="bullet">-</span> 未提交读：脏读、不可重复读、幻读都不能解决</span><br><span class="line"><span class="bullet">-</span> 已提交读：解决脏读</span><br><span class="line"><span class="bullet">-</span> 可重复读：解决脏读和不可重复读</span><br><span class="line"><span class="bullet">-</span> 串行化：全部都能解决（效率低）</span><br><span class="line"></span><br><span class="line">** mysql默认隔离级别</span><br><span class="line">可重复读</span><br></pre></td></tr></table></figure>

<h2 id="12、undo-log和redo-log的区别"><a href="#12、undo-log和redo-log的区别" class="headerlink" title="12、undo log和redo log的区别"></a>12、undo log和redo log的区别</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> redo log：记录的是数据页的物理变化，服务器宕机可以进行同步</span><br><span class="line"><span class="bullet">-</span> undo log：记录的是逻辑日志，当事务回滚时，通过逆向操作来恢复数据</span><br><span class="line">redo log保证了事务的持久性，undo log保证了数据的原子性和一致性</span><br></pre></td></tr></table></figure>

<h2 id="13、事务中的隔离性是如何保证的呢？"><a href="#13、事务中的隔离性是如何保证的呢？" class="headerlink" title="13、事务中的隔离性是如何保证的呢？"></a>13、事务中的隔离性是如何保证的呢？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Mysql中的多版本并发控制。</span><br><span class="line"></span><br><span class="line">** 隐藏字段</span><br><span class="line"><span class="bullet">-</span> trx<span class="emphasis">_id（事务id）：记录每一次操作事务的id，是自增的</span></span><br><span class="line"><span class="emphasis">- roll_</span>pointer（回滚指针）：指向上一个版本的事务版本记录地址</span><br><span class="line"></span><br><span class="line">** unbo log</span><br><span class="line"><span class="bullet">-</span> 回滚日志：存储老版本数据</span><br><span class="line"><span class="bullet">-</span> 版本链：多个事务并行操作某一记录，记录不容事务修改数据的版本，通过           roll<span class="emphasis">_point指针形成一个链表</span></span><br><span class="line"><span class="emphasis">** readView</span></span><br><span class="line"><span class="emphasis">解决事务查询选择版本的问题</span></span><br><span class="line"><span class="emphasis">- 根据readView的匹配规则和当前的一些事务id判断该访问那个版本的数据</span></span><br><span class="line"><span class="emphasis">- 不同隔离级别快照读是不一样的：</span></span><br><span class="line"><span class="emphasis"> -- RC：每一次执行快照时生成ReadView</span></span><br><span class="line"><span class="emphasis"> -- RR：仅在事务中第一次执行快照读时生成ReadView，后续复用</span></span><br></pre></td></tr></table></figure>

<h2 id="14、主从同步原理？"><a href="#14、主从同步原理？" class="headerlink" title="14、主从同步原理？"></a>14、主从同步原理？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Mysql主从复制的核心就是二进制文件。</span><br><span class="line"><span class="bullet">-</span> Master主库在事务提交时，会把数据变更记录在二进制日志文件binlog中</span><br><span class="line"><span class="bullet">-</span> 从库读取主库的二进制文件binlog，写入到从库的中继日志Relaylog中</span><br><span class="line"><span class="bullet">-</span> 从库重做中继日志中的事件，将改变反映它自己的数据</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
        <tag>面试</tag>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>My First Post</title>
    <url>/2023/05/25/14-22-46/</url>
    <content><![CDATA[<h1 id="Hexo-GitHub搭建个人博客"><a href="#Hexo-GitHub搭建个人博客" class="headerlink" title="Hexo+GitHub搭建个人博客"></a>Hexo+GitHub搭建个人博客</h1><span id="more"></span>

<h2 id="1、下载安装Node-js"><a href="#1、下载安装Node-js" class="headerlink" title="1、下载安装Node.js"></a>1、下载安装Node.js</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1W157gtz4EAMA7yqB2jxNyw?pwd=tskj </span><br><span class="line">提取码：tskj</span><br></pre></td></tr></table></figure>

<p>测试安装完成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">win+r 输入cmd 进入命令行</span></span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<h2 id="2、下载Git"><a href="#2、下载Git" class="headerlink" title="2、下载Git"></a>2、下载Git</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1k2Um8-ls4vPdwS7kTH98IA?pwd=tskj </span><br><span class="line">提取码：tskj</span><br></pre></td></tr></table></figure>

<p>测试安装完成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">win+r 输入cmd进入命令行</span></span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>

<h2 id="3、创建Github账号"><a href="#3、创建Github账号" class="headerlink" title="3、创建Github账号"></a>3、创建Github账号</h2><p>github账号创建较为简单，不再赘述。</p>
<h2 id="4、连接GitHub"><a href="#4、连接GitHub" class="headerlink" title="4、连接GitHub"></a>4、连接GitHub</h2><ul>
<li><p>设置用户名和邮箱</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">右击桌面 选择git bash here</span></span><br><span class="line">git config --global user.name &#x27;你的Github名&#x27;</span><br><span class="line">git config --global user.email &#x27;github邮箱&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成ssh密钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">右击桌面 选择git bash here</span></span><br><span class="line">ssh-keygen -t rsa -C &#x27;github邮箱&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一路回车</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加密钥</p>
<p>进入[C:\Users\用户名\ .ssh]目录(记得勾选显示隐藏文件)，用记事本打开id_rsa.pub文件并复制所有内容。</p>
<p>登录github在setting种找到SSH and GPG keys，点击new SSH key。title随便取名，把剪切板内容粘贴到key种，点击Add SSH key完成。</p>
</li>
</ul>
<h2 id="5、验证连接"><a href="#5、验证连接" class="headerlink" title="5、验证连接"></a>5、验证连接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">桌面右击git bash here</span> </span><br><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">出现Are you sure 。。。输入<span class="built_in">yes</span>同意</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示Hi xxx！You are Successful。。代表成功</span></span><br></pre></td></tr></table></figure>

<h2 id="6、创建GitHub-Page"><a href="#6、创建GitHub-Page" class="headerlink" title="6、创建GitHub Page"></a>6、创建GitHub Page</h2><p>GitHub主页右上角加号选择New repository</p>
<ul>
<li>Repository name中输入 用户名.github.io</li>
<li>勾选 “Initialize this repository with a README”</li>
<li>点击Create repository</li>
</ul>
<p>此时博客地址为https:&#x2F;&#x2F;用户名.github.io</p>
<h2 id="7、本地安装Hexo"><a href="#7、本地安装Hexo" class="headerlink" title="7、本地安装Hexo"></a>7、本地安装Hexo</h2><h3 id="7-1安装Hexo"><a href="#7-1安装Hexo" class="headerlink" title="7.1安装Hexo"></a>7.1安装Hexo</h3><p>在本地创建文件夹后进入cmd</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h3 id="7-2初始化"><a href="#7-2初始化" class="headerlink" title="7.2初始化"></a>7.2初始化</h3><p>在hexo目录进入cmd</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化并安装所需组件</span></span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>安装完成后依次输入命令，启动本地服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g # 生成页面</span><br><span class="line">hexo s # 启动预览</span><br></pre></td></tr></table></figure>

<p>访问<a href="http://localhost:4000，出现Hexo默认页面，本地博客安装完成。（加载不出来可能是端口被占用了，Ctrl+C关闭服务，重新启动```hexo">http://localhost:4000，出现Hexo默认页面，本地博客安装完成。（加载不出来可能是端口被占用了，Ctrl+C关闭服务，重新启动```hexo</a> server -p 5000&#96;&#96;&#96;）</p>
<p>Hexo的目录结构为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|- _config.yml  #网站的配置信息</span><br><span class="line">|- package.json #应用程序的信息</span><br><span class="line">|- scaffolds    #模板文件夹</span><br><span class="line">|- source       #存放用户的博客文件，markdown格式</span><br><span class="line">	|- _posts</span><br><span class="line">|- theme        #主题文件夹</span><br><span class="line">|- public       #网站文件</span><br></pre></td></tr></table></figure>

<h2 id="8、部署Hexo到GitHub-Pages"><a href="#8、部署Hexo到GitHub-Pages" class="headerlink" title="8、部署Hexo到GitHub Pages"></a>8、部署Hexo到GitHub Pages</h2><p>本地博客测试成功后，我们可以尝试上传到GitHub进行部署。</p>
<h3 id="8-1安装hexo-deployer-git"><a href="#8-1安装hexo-deployer-git" class="headerlink" title="8.1安装hexo-deployer-git"></a>8.1安装hexo-deployer-git</h3><p>进入hexo所在目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h3 id="8-2修改-config-yml文件"><a href="#8-2修改-config-yml文件" class="headerlink" title="8.2修改_config.yml文件"></a>8.2修改_config.yml文件</h3><p>修改Hexo目录下的_config.yml文件，在文件末尾添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	type: git</span><br><span class="line">	repository: git@github.com:用户名/用户名.github.io.git</span><br><span class="line">	branch: master</span><br></pre></td></tr></table></figure>

<h3 id="8-3上传部署"><a href="#8-3上传部署" class="headerlink" title="8.3上传部署"></a>8.3上传部署</h3><figure class="highlight plaintext"><figcaption><span>d```将网站上传到GitHub　Pages</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">此时我们通过https://用户名.github.io就可以访问了</span><br><span class="line"></span><br><span class="line">## 9、绑定域名</span><br><span class="line"></span><br><span class="line">### 9.1域名注册与解析</span><br><span class="line"></span><br><span class="line">我这里是通过腾讯云购买的域名，购买完成后在我的域名下可以通过解析进行域名解析。</span><br><span class="line"></span><br><span class="line">### 9.3域名解析</span><br><span class="line"></span><br><span class="line">输入cmd打开命令行，输入```ping 用户名.github.io```得到主机地址.</span><br><span class="line"></span><br><span class="line">![](./My-First-Post/QQ截图20230525152245.png)</span><br><span class="line"></span><br><span class="line">在域名解析中添加记录，主机记录为@,记录类型为A，记录值为主机地址，点击确认。</span><br><span class="line"></span><br><span class="line">再添加一条主机地址为www,记录类型为CNAME，记录值为```用户名.github.io```点击确认。</span><br><span class="line"></span><br><span class="line">- 再进入你的GitHub Pages</span><br><span class="line">- 点击settings</span><br><span class="line">- 点击pages</span><br><span class="line">- 找到Custom domain 输入你的域名地址不带www（比如abc.cn）</span><br><span class="line">- 将下方的Enforce HTTPS勾选</span><br><span class="line">- 在你的Hexo文件目录下的source下创建文本文件，名为CNAME保存为全部类型（不带.txt）。该文件内容为你的域名地址如：https://abc.cn</span><br><span class="line"></span><br><span class="line">## 10、使用</span><br><span class="line"></span><br><span class="line">### 10.1 发布文章</span><br><span class="line"></span><br><span class="line">进入博客目录所在</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"># 创建博文</span><br><span class="line">hexo new &quot;My first text&quot;</span><br></pre></td></tr></table></figure>

<p>完成后会在source目录下生成一个md文件</p>
<p>写完后可以通过命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g # 生成页面</span><br><span class="line">hexo d # 部署发布</span><br></pre></td></tr></table></figure>

<p>当然也可以使用自己的md文件，只需要在文件开头加入Front-matter即可</p>
<p>完成后的提交命令同上。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/2023/05/28/14-22-46/</url>
    <content><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><span id="more"></span>

<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>​	nginx是一款轻量级的web服务器&#x2F;反向代理服务器及电子邮件代理服务器，其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好。</p>
<h2 id="Nginx命令-在sbin下"><a href="#Nginx命令-在sbin下" class="headerlink" title="Nginx命令(在sbin下)"></a>Nginx命令(在sbin下)</h2><h3 id="查看版本号"><a href="#查看版本号" class="headerlink" title="查看版本号"></a>查看版本号</h3><p>​	.&#x2F;nginx -v</p>
<h3 id="检查配置文件正确性"><a href="#检查配置文件正确性" class="headerlink" title="检查配置文件正确性"></a>检查配置文件正确性</h3><p>​	在启动Nginx服务之前，可以先检查一下conf&#x2F;nginx.conf文件配置的是否有错误：.&#x2F;nginx -t</p>
<h3 id="启动和停止"><a href="#启动和停止" class="headerlink" title="启动和停止"></a>启动和停止</h3><p>​	启动Nginx服务：.&#x2F;nginx</p>
<p>​	停止Nginx服务：.&#x2F;nginx -s stop</p>
<p>​	启动完成后查看nginx进程：ps -ef|grep nginx</p>
<h3 id="重新加载配置文件"><a href="#重新加载配置文件" class="headerlink" title="重新加载配置文件"></a>重新加载配置文件</h3><p>​	当修改nginx配置文件后，需要重新加载才能生效：.&#x2F;nginx -s reload</p>
<h3 id="Nginx配置文件结构"><a href="#Nginx配置文件结构" class="headerlink" title="Nginx配置文件结构"></a>Nginx配置文件结构</h3><h4 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h4><p>​		和nginx运行相关的全局配置</p>
<h4 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h4><p>​		和网络连接相关的配置</p>
<h4 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h4><p>​	http块中可以配置多个Server块，每个Server块中可以配置多个location块</p>
<p>​		代理、缓存、日志文件、虚拟主机配置</p>
<h5 id="http全局块"><a href="#http全局块" class="headerlink" title="http全局块"></a>http全局块</h5><h5 id="Server块"><a href="#Server块" class="headerlink" title="Server块"></a>Server块</h5><h6 id="Server全局块"><a href="#Server全局块" class="headerlink" title="Server全局块"></a>Server全局块</h6><h6 id="location块"><a href="#location块" class="headerlink" title="location块"></a>location块</h6><h2 id="Nginx具体应用"><a href="#Nginx具体应用" class="headerlink" title="Nginx具体应用"></a>Nginx具体应用</h2><h3 id="部署静态资源"><a href="#部署静态资源" class="headerlink" title="部署静态资源"></a>部署静态资源</h3><p>​	nginx可以作为静态web服务器来部署静态资源。如：css、html、js、图片、视频等资源</p>
<p>​	相对于Tomcat，Nginx处理静态资源的能力更加高效，所以在生产环境下，一般都会将静态资源部署到nginx中</p>
<p>​	将静态资源部署到Nginx非常简单，只需要将文件复制到Nginx安装目录下的html目录中即可。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">servet&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;    <span class="comment">#监听端口</span></span><br><span class="line">	<span class="attribute">server_name</span> localhost;	服务器名称 </span><br><span class="line">	<span class="section">location</span> /&#123;	<span class="comment">#匹配客户端请求url</span></span><br><span class="line">		<span class="attribute">root</span> html;	<span class="comment">#指定静态资源根目录</span></span><br><span class="line">		<span class="attribute">index</span> index.html;	<span class="comment">#指定默认首页</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>​	</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">82</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="section">location</span> /&#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/api/(.*)$</span> /<span class="variable">$1</span> <span class="literal">break</span>; <span class="comment">#截取掉多余的路径</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://ip地址; <span class="comment">#反向代理配置，将请求转发到指定服务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>​	早期的网站流量和业务功能都比较简单，单台服务器就可以满足基本需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器组成应用集群，进行性能的水平扩展以及避免单点故障出现。</p>
<p>​	应用集群：将同一应用部署到多台机器上，组成应用集群，接受负载均衡器分发的请求，进行业务处理并返回响应数据</p>
<p>​	负载均衡器：将用户请求根据对应的负载均衡算法分发到应用集群中的一台服务器进行处理。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> targetserver&#123;	<span class="comment">#upstream指令可以定义一组服务器</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.138.101:8080</span> weight=<span class="number">10</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.138.101:8081</span>;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="section">location</span> /&#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://targetserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	负载均衡策略：</p>
<p>​		</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>轮询</td>
<td>默认方式</td>
</tr>
<tr>
<td>weight</td>
<td>权重方式</td>
</tr>
<tr>
<td>ip_hash</td>
<td>依据ip分配方式</td>
</tr>
<tr>
<td>least_conn</td>
<td>一句最少连接方式</td>
</tr>
<tr>
<td>url_hash</td>
<td>一句url分配方式</td>
</tr>
<tr>
<td>fair</td>
<td>一句响应时间方式</td>
</tr>
</tbody></table>
<p>​		</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Nginx</tag>
        <tag>反向代理</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2023/05/28/14-22-46/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><span id="more"></span>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis是一个基于内存的key—value结构数据库</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>基于内存存储读写性能高</li>
<li>适合存储热点数据（频繁访问、读取）</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>字符串string</li>
<li>哈希hash</li>
<li>列表list</li>
<li>集合set</li>
<li>有序集合sorted set</li>
</ul>
<h3 id="字符串（常用命令）"><a href="#字符串（常用命令）" class="headerlink" title="字符串（常用命令）"></a>字符串（常用命令）</h3><ol>
<li><p>Set key value                               设置指定key的值</p>
</li>
<li><p>Get key                                         获取指定key的值</p>
</li>
<li><p>SETEX key seconds value        设置指定key的值，并将key的过期时间设为seconds秒</p>
</li>
<li><p>SETNX  key value                      只有在key不存在时设置key的值</p>
</li>
</ol>
<h3 id="哈希hash"><a href="#哈希hash" class="headerlink" title="哈希hash"></a>哈希hash</h3><p>​			Redis hash 是一个string类型的field和value的映射表，hash			特别适合用于存储对象，注：它一个key对应的一个value中			又是一个field对应一个value常用命令：	</p>
<ol>
<li><p>​	HSET key field value    将哈希表key中的字段field的值设为value</p>
</li>
<li><p>​    HGET key field    获取存储在哈希表中指定字段的值</p>
</li>
<li><p>​    HDEL key field    删除存储在哈希表中的指定字段</p>
</li>
<li><p>​    HKEYS key           获取哈希表中所有字段</p>
</li>
<li><p>​    Hvals key              获取哈希表中所有值</p>
</li>
<li><p>​    HGETALL key      获取在哈希表中指定key的所有字段和值</p>
</li>
</ol>
<h3 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h3><p>​			Redis列表是最简单的字符串列表，按照插入顺序排序，常用命令：</p>
<ol>
<li>LPUSH key value1 [value2]    将一个或多个值插入到列表头部</li>
<li>LRANGE key start stop            获取列表指定范围内的元素</li>
<li>RPOP key                                    移除并获取列表最后一个元素</li>
<li>LLEN key                                     获取列表长度</li>
<li>BRPOP key1 [key2] timeout    移出并获取列表最后一个元素，如果列表没有元素会阻塞列表直到等到超时或发现可以弹出元素为止</li>
</ol>
<h3 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h3><p>Redis set是string类型的无序集合，集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令：</p>
<ol>
<li>SADD key member1 [member2]   向集合添加一个或多个成员</li>
<li>SMEMNERS key                               返回集合中的所有成员</li>
<li>SCARD key                                        获取集合的成员数</li>
<li>SINTER  key1 [key2]                        返回给定所有集合的交集</li>
<li>SUNION key1 [key2]                       返回所有给定集合的并集</li>
<li>SDIFF key1 [key2]                            返回所有给定集合的差集</li>
<li>SREM key member1 [member2]   移除集合中一个或多个成员</li>
</ol>
<h3 id="sorted-set有序集合"><a href="#sorted-set有序集合" class="headerlink" title="sorted set有序集合"></a>sorted set有序集合</h3><p>Redis sorted set有序集合是string类型元素的集合，且不允许重复的成员。每个元素都会关联一个double类型的分数score，redis正是通过分数来为集合中的成员进行从小到大排序，有序集合的成员是唯一的，但分数却可以重复，常用命令：</p>
<ol>
<li>ZADD key score1 member1 [score2 member2]  向有序集合添加一个或多个成员，或者更新已存在成员的分数</li>
<li>ZRANGE  key start stop [WITHSCORES]             通过索引区间返回有序集合中指定区间内的成员</li>
<li>ZINCRBY key increment member                        有序集合中对指定成员的分数加上增量 increment</li>
<li>ZREM key member [member…]                             移除有序集合中的一个或多个成员</li>
</ol>
<h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ol>
<li>KEYS pattern     查找所有符合给定模式pattern的key</li>
<li>EXISTS key         检查给定key是否存在</li>
<li>TYPE  key           返回key所存储的值的类型</li>
<li>TTL key               返回给定key的剩余生存时间（TTL，time to live），以秒为单位</li>
<li>DEL key               该命令用于在key存在是删除key</li>
<li>Select <bind>  切换到bind数据库</bind></li>
</ol>
<h3 id="spring-cache注解："><a href="#spring-cache注解：" class="headerlink" title="spring cache注解："></a>spring cache注解：</h3><p>cacheManger是spring提供的各种缓存技术抽象接口 可以用autowired自动注入</p>
<p>注解可以用#result.id   或#p0.id   或 #user.id或#root.args[0].id    参数需要和参数名相同 如 #id</p>
<p>yml文件中cache redis time to live可以设置缓存过期时间</p>
<p>返回结果集需要实现序列化接口才可以被放到redis中</p>
<ol>
<li>@EnableCaching          开启注解功能，放在启动类上</li>
<li>@Cacheable                       在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</li>
<li>@CachePut                    将方法的返回值放到缓存中</li>
<li>@CacheEvict                 将一条或多条数据从缓存中删除</li>
</ol>
<h4 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut:"></a>@CachePut:</h4><ol>
<li><p>value:缓存的名字，每个缓存名称下面可以有多个key</p>
</li>
<li><p>key:缓存的key	</p>
<p>​</p>
</li>
</ol>
<p>	</p>
<h4 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict:"></a>@CacheEvict:</h4><p>​		注解中可以使用#result</p>
<ol>
<li>value:要删除value</li>
<li>key:删除value下指定的key</li>
<li>allEntries:true  删除value下的所有cache</li>
<li>beforeInvocation:在方法执行前清除缓存</li>
</ol>
<h4 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable:"></a>@Cacheable:</h4><ol>
<li><p>value:缓存的名字，每个缓存名称下面可以有多个key</p>
</li>
<li><p>key:缓存的key		</p>
</li>
<li><p>condition:当满足条件时缓存数据</p>
</li>
<li><p>unless:当满足条件时不缓存数据</p>
</li>
</ol>
<h2 id="MySql主从复制"><a href="#MySql主从复制" class="headerlink" title="MySql主从复制"></a>MySql主从复制</h2><p>mysql主从复制是一个异步的复制过程，底层是基于mysql数据库自带的二进制日志功能。就是一台或多台mysql数据库（slave，即从库）从另一台mysql数据库（master，即主库）进行日志的复制然后再解析日志并应用到自身，最中实现从库和主库的数据保持一致。mysql’主从复制是mysql’数据库自带功能，无需借助第三方工具</p>
<h3 id="配置-主库MMaster"><a href="#配置-主库MMaster" class="headerlink" title="配置-主库MMaster"></a>配置-主库MMaster</h3><p>​		第一步：修改msysql数据库的配置文件&#x2F;etc&#x2F;my.cnf</p>
<p>​			[mysqld]</p>
<p>​			log-bin &#x3D; mysql-bin    #[必须]启用二进制日志</p>
<p>​			server-id&#x3D;100			#[必须]服务器唯一ID</p>
<p>​		第二步：重启mysql服务</p>
<p>​			systemctl restart mysqld</p>
<p>​		第三步：登录mysql数据库，执行以下sql</p>
<p>​			GRANT REPLICATION SLAVE ON  * . *  to ‘xiaoming‘@’%’ identified by 			‘Root@123456’</p>
<p>​			注：上面sql的作用是创建一个用户xiaoming，密码为Root@123456，并且			给xiaoming用户授权PERLICATION SLAVE 权限。常用于建立复制时所需要			用到的用户权限，也就是slave必须被master授权具有该权限的用户，才能通			过该用户复制。密码需要数字，大小写，特殊字符长度8位</p>
<p>​		第四步：登录mysql数据库，执行下面sql，记录结果中File和Position的值</p>
<p>​			show master status</p>
<p>​			注：上面sql的作用时查看master的状态，执行完此sql 后不要再执行任何操作</p>
<h3 id="配置-从库Slave"><a href="#配置-从库Slave" class="headerlink" title="配置-从库Slave"></a>配置-从库Slave</h3><p>​			第一步：修改mysql数据库的配置文件&#x2F;etc&#x2F;my.cnf</p>
<p>​				[mysqld]</p>
<p>​				server-id&#x3D;101  #[必须]	服务器唯一ID</p>
<p>​			第二步：重启mysql服务</p>
<p>​				systemctl restart mysqld</p>
<p>​			第三步：登录mysql数据库，执行下面sql</p>
<p>​				change master to master_host&#x3D;’192.168.138.100’,master_user&#x3D;’xiaoming’,master_password&#x3D;‘Root@123456’,master_log_file&#x3D;’mysql-bin.000001’,master_log_pos&#x3D;439;</p>
<p>​				start slave;</p>
<p>​				注：master_host:主服务器IP地址，master_user：授权的用户名，master_password授权的用户的密码，master_log_file：master的状态中file的值，</p>
<p>master_log_pos:mster的状态中position中的值</p>
<p>​			第四步：登录mysql数据库，执行下面sql，查看从库状态</p>
<p>​				show slave status;</p>
<h2 id="Springboot拦截器使用redis"><a href="#Springboot拦截器使用redis" class="headerlink" title="Springboot拦截器使用redis"></a>Springboot拦截器使用redis</h2><p>pom依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>拦截器实现HandlerInterceptor</li>
<li>配置文件添加拦截器</li>
<li>拦截器中的RedisTemplate不用@autowired注解用@Resource</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记</title>
    <url>/2023/05/29/15-33-46/</url>
    <content><![CDATA[<h1 id="Redis从入门到放弃"><a href="#Redis从入门到放弃" class="headerlink" title="Redis从入门到放弃"></a>Redis从入门到放弃</h1><h2 id="1、初识Redis"><a href="#1、初识Redis" class="headerlink" title="1、初识Redis"></a>1、初识Redis</h2><span id="more"></span>

<h3 id="1-1、SQL和NoSql区别"><a href="#1-1、SQL和NoSql区别" class="headerlink" title="1.1、SQL和NoSql区别"></a>1.1、SQL和NoSql区别</h3><p>SQL：关系型数据库</p>
<p>NOSQL：非关系型数据库</p>
<p>区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>SQL</th>
<th>NOSQL</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>结构化</td>
<td>非结构化</td>
</tr>
<tr>
<td>数据关联</td>
<td>关联</td>
<td>非关联</td>
</tr>
<tr>
<td>查询方式</td>
<td>SQL查询</td>
<td>非SQL</td>
</tr>
<tr>
<td>事务特性</td>
<td>ACID</td>
<td>BASE</td>
</tr>
<tr>
<td>存储方式</td>
<td>磁盘</td>
<td>内存</td>
</tr>
<tr>
<td>扩展性</td>
<td>垂直</td>
<td>水平</td>
</tr>
<tr>
<td>使用场景</td>
<td>1、数据结构固定<br>2、相对业务对数据安全性、一致性要求较高</td>
<td>1、数据结构不固定<br>2、对一致性、安全性要求不高<br>3、对性能要求高</td>
</tr>
</tbody></table>
<p>结构化：比如字段约束，约束后只能遵循约束规则存储</p>
<p>非结构化：对存储的内容约束没那么多要求</p>
<h3 id="1-2、认识Redis"><a href="#1-2、认识Redis" class="headerlink" title="1.2、认识Redis"></a>1.2、认识Redis</h3><p>Redis诞生于2009年，全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NOSQL数据库。</p>
<p>特征：</p>
<ul>
<li>键值(key-value)型：value支持多种不同数据结构，功能服务。</li>
<li>单线程：每个命令具备原子性</li>
<li>低延迟，速度快：基于内存，IO多路复用，良好的编码</li>
<li>支持数据持久化：定期将数据从内存持久化到磁盘。</li>
<li>支持主从集群、分片集群</li>
<li>支持多语言客户端</li>
</ul>
<h3 id="1-3、安装Redis"><a href="#1-3、安装Redis" class="headerlink" title="1.3、安装Redis"></a>1.3、安装Redis</h3><h4 id="1-3-1"><a href="#1-3-1" class="headerlink" title="1.3.1"></a>1.3.1</h4>]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>学习笔记</tag>
        <tag>坚持</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud</title>
    <url>/2023/05/28/14-22-46/</url>
    <content><![CDATA[<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><span id="more"></span>

<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h3 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a>什么是微服务？</h3><p>微服务不等于springcloud，微服务是一种经过良好架构设计的分布架构方案，微服务架构特征：</p>
<ol>
<li>单一职责：微服务拆分粒度更小。每一个服务都对应唯一的业务能力，做到职责单一，避免业务重复开发</li>
<li>面向服务：微服务对外暴露业务接口</li>
<li>自治：团队独立，技术独立，数据独立，部署独立</li>
<li>隔离性强：服务调用做好隔离，容错，降级，避免出现级联问题</li>
</ol>
<h3 id="微服务技术栈"><a href="#微服务技术栈" class="headerlink" title="微服务技术栈"></a>微服务技术栈</h3><p>微服务做的第一件事就是拆分，因为传统单体架构，所有的业务功能全部写在一起，随着业务越来越复杂，代码也耦合的越来越多，将来升级维护就会变得很困难，所以大型的互联网服务都会进行拆分。微服务再做拆分的时候，会根据业务功能模块把一个单体的项目拆分成许多的独立的项目，每个项目完成一部分业务功能，将来独立开发或部署，我们把这一个独立的项目称为服务，一个大型的互联网项目往往会包含数百上千的服务最终形成一个服务集群，而一个业务往往就需要多个服务共同完成。比如说一个请求来了，他可能先去调用服务A，而服务A可能又调用了服务B，而后又去调用了服务C。当业务越来越多也来越复杂的时候，这些服务的调用关系就会越来越复杂，这么复杂的调用关系要让人去记录和维护是不可能的。所以再微服务里会又一个组件叫<strong>注册中心</strong>，它可以去记录微服务里每个服务的ip、端口，以及他们的功能。当有一个服务需要调用另一个服务时它不需要自己去记录对方的ip，只需要去找注册中心就可以，从注册中心去拉取对应的服务信息。同时随着服务越来越多每个服务都有自己的配置文件，将来要更改配置我们要逐一去修改这样就太麻烦了，所以我们还会有一个<strong>配置中心</strong>。它可以去统一的管理整个服务群里成千上百个配置，如果以后又配置需要变更只需要去 找配置中心，他会通知相关的微服务实现配置的热更新当我们的微服务运行起来之后，用户就可以来访问我们了，这时候就还需要一个<strong>网关服务</strong>。那你这里有这么多微服务，用户怎么知道你要访问哪一个呢？而且也不是随便什么人都可以访问我们的服务，这就像是我们的小区，小区里往往有一个看门的大爷，不能什么人来了都可以进入。所以服务网关一部分是对用户身份进行校验，另一方面可以把用户的请求路由到具体的服务，当然再路由过程中也可以去做一些负载均衡。而这时候服务集群根据你的请求去处理业务，该访问数据库就访问数据库并把查询到的数据返回给用户。数据库肯定也是集群，不过集群在庞大也不会有用户数量多，所以数据库将来肯定无法抗住高并发，因此我们还会加入<strong>分布式缓存</strong>， 但是简单查询可以走缓存，一些海量数据的复杂的搜索统计和分析缓存也做不了，这时候就还需要用到<strong>分布式搜索功能</strong>。数据库将来的功能就只需要做一些写操作和一些事务类型的对数据安全较高的一些数据存储。最后再微服务里面还需要一种<strong>异步通讯的消息队列组件</strong>。为什么呢？其实对于分布式的服务或再微服务里面，他的业务往往会跨越多个服务，所以总时长就会等于每个服务执行时长之和，性能就会下降，而异步通讯的意思就是请求来了我调用服务A，而服务A不是去调用服务B和C而是通知他们，B和C去执行之后A就直接结束了，那么通信链路就变短了执行时长也就短了 。所以异步通讯可以大大提高我们的并发，再一些秒杀等高并发场景下就可以去利用了。当然我们如此庞大复杂的一个服务在运行的过程中如果出现什么问题也不好排查。所以在微服务运行中还会引入两个组件来解决这种异常定位。第一个是<strong>分布式日志服务</strong>，它可以去统计整个集群中成千上百个服务他们的运行日志，统一的去做一个存储，统计，分析。将来出现问题就比较好定位了。第二个叫做<strong>系统监控链路追踪</strong>，他可以去实时监控我们整个集群中每个服务节点的运行状态，Cpu的负载、内存的占用等等情况，一旦出现问题直接可以定位到具体的某一个方法和栈信息。那这么大的服务怎么部署呢？未来我们会做一些自动化的部署，<strong>持续集成</strong>：利用<strong>Jenkins</strong>这样的工具，它可以帮助我们对这些微服务项目进行自动化的编译，而基于<strong>Docker</strong>来进行一些打包形成镜像，再基于<strong>kubernetes</strong>或<strong>rancher</strong>这样的技术实现自动化的部署，这一套我们就称为叫持续集成。以上全部才叫做微服务技术栈</p>
<h3 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h3><p>单体架构：将业务的所有功能集中在一个项目中开发，达成一个包部署。</p>
<p>优点：</p>
<ol>
<li>架构简单</li>
<li>部署成本低</li>
</ol>
<p>缺点：</p>
<ol>
<li>耦合度高</li>
</ol>
<p>分布式架构：</p>
<p>分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。</p>
<ol>
<li>降低服务耦合</li>
<li>有利于服务升级拓展</li>
</ol>
<p>分布式架构要考虑的问题：</p>
<ul>
<li>服务拆分粒度如何？</li>
<li>服务集群地址如何维护？</li>
<li>服务之间如何实现远程调用？</li>
<li>服务健康状态如何感知？</li>
</ul>
<h2 id="微服务远程调用"><a href="#微服务远程调用" class="headerlink" title="微服务远程调用"></a>微服务远程调用</h2><h3 id="微服务调用方式"><a href="#微服务调用方式" class="headerlink" title="微服务调用方式"></a>微服务调用方式</h3><ol>
<li>基于RestTemplate发起的http请求实现远程调用</li>
<li>http请求做远程调用是 与语言无关的调用，只要知道对方的ip、端口、接口路径、请求参数即可</li>
</ol>
<h3 id="提供者与消费者"><a href="#提供者与消费者" class="headerlink" title="提供者与消费者"></a>提供者与消费者</h3><ul>
<li>服务提供者：一次业务中，被其他微服务调用的服务（提供接口给其他微服务）</li>
<li>服务消费者：一次业务中，调用其他微服务的服务（调用其他微服务提供的接口）</li>
</ul>
<p>​			如果服务A调用服务B，服务B调用了服务C，那么服务B是什么角色？</p>
<p>​			一个服务既可以是提供者也可以是消费者</p>
<h2 id="EureKa注册中心"><a href="#EureKa注册中心" class="headerlink" title="EureKa注册中心"></a>EureKa注册中心</h2><h3 id="服务调用出现的问题"><a href="#服务调用出现的问题" class="headerlink" title="服务调用出现的问题"></a>服务调用出现的问题</h3><ul>
<li>服务消费者该如何获取服务提供者的地址信息？</li>
<li>如果有多个服务提供者，消费者该如何选择？</li>
<li>消费者如何得知服务提供者的健康状态？</li>
</ul>
<h3 id="EureKa的作用"><a href="#EureKa的作用" class="headerlink" title="EureKa的作用"></a>EureKa的作用</h3><p>在Eureka架构中，微服务角色有两类：</p>
<ol>
<li>EurekaServer：服务端，注册中心<ul>
<li>记录服务信息</li>
<li>心跳监控</li>
</ul>
</li>
<li>EurekaClient：客户端<ul>
<li>Provider：服务提供者，例如案例中的user-service<ol>
<li>注册自己的信息到EurekaServer</li>
<li>每隔30秒向EurekaServer发送心跳</li>
</ol>
</li>
<li>consumer：服务消费者，例如案例中的order-service<ol>
<li>根据服务名称从EurekaServer拉取服务列表</li>
<li>基于服务列表做负载均衡，选中一个微服务后发起远程调用</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>具体问题：</p>
<ul>
<li>消费者该如何获取服务提供者具体信息？<ol>
<li>服务提供者启动时向eureka注册自己的信息</li>
<li>eureka保存这些信息</li>
<li>消费者根据服务名称向eureka拉取提供者信息</li>
</ol>
</li>
<li>如果有多个服务提供者，消费者该如何选择？<ol>
<li>服务消费者利用负载均衡算法，从服务列表中挑选一个</li>
</ol>
</li>
<li>消费者如何感知服务提供者的健康状态？<ol>
<li>服务提供者会每隔30秒向eurekaserver发送心跳请求，报告健康状态</li>
<li>eureka会更新记录服务器列表信息，心跳不正常会被剔除</li>
<li>消费者就可以拉取到最新的消息</li>
</ol>
</li>
</ul>
<h3 id="搭建EurekaServer"><a href="#搭建EurekaServer" class="headerlink" title="搭建EurekaServer"></a>搭建EurekaServer</h3><p>搭建EurekaServer服务步骤如下：</p>
<ol>
<li><p>创建项目，引入spring-cloud-starter-netflix-eureka-server的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org,springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifacrId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifacrId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
</li>
<li><p>编写启动类，添加@EnableEurekaServer注解</p>
</li>
<li><p>添加application.yml文件，编写下面的配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span> <span class="comment">#端口</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span> <span class="comment">#服务名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eurekaServer</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment">#eureka的地址信息</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:8084/eureka</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>服务注册步骤</p>
<ol>
<li><p>在要注册的服务下引入spring-cloud-starter-netflix-eureka-client</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org,springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifacrId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifacrId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在application.yml文件添加</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span> <span class="comment">#端口</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span> <span class="comment">#服务名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">UserService</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment">#eureka的地址信息</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:8084/eureka</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>代码请求地址中将ip和端口号改为eureka的服务名,并给restTemplate添加@loadBanlanced开启负载均衡</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h4 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h4><h5 id="负载均衡原理"><a href="#负载均衡原理" class="headerlink" title="负载均衡原理"></a>负载均衡原理</h5><p>ribbon通过获取主机名来对eureka进行获取服务地址，然后通过轮询或者随机来完成负载均衡</p>
<h5 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h5><table>
<thead>
<tr>
<th align="left">内置负载均衡规则类</th>
<th>规则描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">RoundRobinRule</td>
<td>简单轮询服务列表来选择服务器。他是Ribbon默认的负载均很规则</td>
</tr>
<tr>
<td align="left">AvailablitityFilteringRule</td>
<td>对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”转台。短路状态将持续30秒，如果再次连接失败，短路的持续 时间就会几何级数的增加。（2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilterRule规则的客户端也会将其忽略。并发连接数的上线可以由客户端的<clientName><vlientConfigNameSpace>.ActiveConnectionsLimit属性进行配置</vlientConfigNameSpace></clientName></td>
</tr>
<tr>
<td align="left">weightedResponseTimeRule</td>
<td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>
</tr>
<tr>
<td align="left">BestAvailableRule</td>
<td>忽略那些短路的服务器，并选择并发数较低的服务器</td>
</tr>
<tr>
<td align="left">ZoneAvailableRule</td>
<td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个几架等。而后再对Zone的多个服务做轮询</td>
</tr>
<tr>
<td align="left">RandomRule</td>
<td>随机选择一个可用的服务器</td>
</tr>
<tr>
<td align="left">RetryRule</td>
<td>重试机制的选择逻辑</td>
</tr>
</tbody></table>
<p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p>
<p>1、代码方式在配置类中定义一个新的IRule：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、配置文件方式：yml文件中添加新的配置也可以修改规则：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">	<span class="attr">ribbon:</span></span><br><span class="line">		<span class="string">NFLoadBalancerRuleClassName:com.netflix.loadbalancer.RandomRule</span>  <span class="comment">#负载均衡规则</span></span><br></pre></td></tr></table></figure>



<h5 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h5><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ribbon:</span><br><span class="line">	eager-load:</span><br><span class="line">		enabled: true #开启饥饿加载</span><br><span class="line">		clients: </span><br><span class="line">			-userservice #指定对userservice这个服务饥饿加载</span><br><span class="line">			-xxservice</span><br></pre></td></tr></table></figure>

<h2 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h2><h3 id="认识和安装Nacos"><a href="#认识和安装Nacos" class="headerlink" title="认识和安装Nacos"></a>认识和安装Nacos</h3><p>Nacos是阿里巴巴的产品，现在是SpringCloud中的一个组件。相比Eureka功能更加丰富，在国内受欢迎程度较高。</p>
<h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><ol>
<li>安装nacos</li>
<li>nacos默认端口：8848，修改端口在application.properties</li>
<li>nacos启动命令:startup.cmd -m standalone</li>
<li>登录名和密码都为nacos</li>
</ol>
<h3 id="服务注册到Nacos"><a href="#服务注册到Nacos" class="headerlink" title="服务注册到Nacos"></a>服务注册到Nacos</h3><ol>
<li><p>在cloud-demo父工程中添加spring-cloud-alibaba的管理依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artfactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artfactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注释掉order-service和user-service中原有的eureka依赖</p>
</li>
<li><p>添加nacos的客户端依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependecy</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artfactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artfactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependecy</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改user-service和order-service中的application.yml文件，注释eureka地址，添加nacos地址：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">	cloud:</span><br><span class="line">		nacos:</span><br><span class="line">			server-addr: localhost:8848 #nacos  服务端地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动并测试</p>
</li>
</ol>
<h3 id="nacos服务分级存储模型"><a href="#nacos服务分级存储模型" class="headerlink" title="nacos服务分级存储模型"></a>nacos服务分级存储模型</h3><p>一个服务的多个实例分开放</p>
<ol>
<li><p>修改application.yml文件，添加以下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">nacos:</span></span><br><span class="line">			<span class="attr">server-addr:</span> <span class="comment">#nacos  服务端地址</span></span><br><span class="line">			<span class="attr">discovery:</span></span><br><span class="line">				<span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment">#配置集群名称，也就是机房位置，例如：HZ，杭州</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>1、Nacos服务分级存储模型：</p>
<ul>
<li>一级是服务，例如userservice</li>
<li>二级是集群，例如杭州或上海</li>
<li>三级是实例，例如杭州机房的某台部署了userservice的服务器</li>
</ul>
<p>2、如何设置实例的集群属性</p>
<ul>
<li>修改application.yml文件，添加spring.cloud.nacos.discovery.cluster-name属性即可</li>
</ul>
<h4 id="根据集群负载均衡"><a href="#根据集群负载均衡" class="headerlink" title="根据集群负载均衡"></a>根据集群负载均衡</h4><ol>
<li><p>修改order-service中的application.yml，设置集群为HZ</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">nacos:</span></span><br><span class="line">			<span class="attr">server-addr:</span> <span class="string">localhost:8848</span>  <span class="comment">#nacos服务器地址</span></span><br><span class="line">			<span class="attr">discovery:</span></span><br><span class="line">				<span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment">#配置集群名称，也就是机房位置</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后再order-service中设置负载均衡的Rule为NacosRule，这个规则会优先寻找与自己同集群的服务:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">	<span class="attr">ribbon:</span></span><br><span class="line">		<span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment">#负载均衡策略</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意将user-service的权重都设置为1</p>
</li>
</ol>
<h4 id="根据权重负载均衡"><a href="#根据权重负载均衡" class="headerlink" title="根据权重负载均衡"></a>根据权重负载均衡</h4><p>实际部署中会出现这样的场景：</p>
<ul>
<li>服务器设备性能有差异，部分实例所在及其性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求</li>
</ul>
<p>nacos提供了权重配置来控制访问频率，权重越大则访问频率越高</p>
<ol>
<li>在nacos控制台可以设置实例的权重值，首先选中实例后面的编辑按钮</li>
<li>将权重设置为0.1，则该实例被访问到的概率将大大降低</li>
</ol>
<p>总结：</p>
<ol>
<li>nacos控制台可以设置实例的权重值，0-1之间</li>
<li>同集群内的多个实例，权重越高被访问的频率越高</li>
<li>权重设置为0则完全不会被访问（可以做项目的平滑升级）</li>
</ol>
<h3 id="环境隔离-namespace"><a href="#环境隔离-namespace" class="headerlink" title="环境隔离-namespace"></a>环境隔离-namespace</h3><p>nacos中服务存储和数据存储的最外层都是一个名为namespace的东西，用来做最外层隔离</p>
<p>步骤：</p>
<ol>
<li><p>在nacos控制台中的命名空间添加命名空间</p>
</li>
<li><p>在要隔离的yml文件中添加namespace</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">nacos:</span></span><br><span class="line">			<span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">			<span class="attr">discovery:</span></span><br><span class="line">				<span class="attr">cluster-name:</span> <span class="string">SH</span></span><br><span class="line">				<span class="attr">namespace:</span> <span class="string">命名空间id</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>总结：</p>
<ol>
<li>namespzce用来做环境隔离</li>
<li>每个namespace都有唯一id</li>
<li>不同namespace下的服务不可见</li>
</ol>
<h3 id="Nacos与eureka的区别"><a href="#Nacos与eureka的区别" class="headerlink" title="Nacos与eureka的区别"></a>Nacos与eureka的区别</h3><ol>
<li>Nacos与eureka的共同点<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ul>
</li>
<li>Nacos与Eureka的区别<ul>
<li>nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>
<li>nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>nacos集群默认采用ap方式，当集群中存在非临时实例时，采用cp模式；eureka采用ap方式</li>
</ul>
</li>
</ol>
<p>服务注册到nacos时，可以选择注册为临时或非临时实例，通过下面的配置来设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">nacos:</span></span><br><span class="line">			<span class="attr">discovery:</span></span><br><span class="line">				<span class="attr">ephemeral:</span> <span class="literal">false</span>  <span class="comment">#设置是否为临时实例</span></span><br></pre></td></tr></table></figure>

<h2 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h2><h3 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h3><ol>
<li>在nacos中添加配置信息</li>
<li>在弹出的表单中填写配置信息<ul>
<li>配置文件的id：[服务名称]-[profile].后缀名</li>
<li>分组  默认即可</li>
<li>格式  目前支持yaml  和properties</li>
<li>完成</li>
</ul>
</li>
<li>最好只配置需要热更新的配置</li>
</ol>
<h3 id="微服务配置拉取"><a href="#微服务配置拉取" class="headerlink" title="微服务配置拉取"></a>微服务配置拉取</h3><ol>
<li><p>在nacos中添加配置文件</p>
</li>
<li><p>在微服务中引入nacos的config依赖</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;!--导入nacos配置依赖--&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在微服务中添加bootstrap.yml(引导文件，优先级高于application.yml)，配置nacos地址、当前环境、服务名称、文件后缀名。这些决定了程序启动时去nacos读取那个文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> <span class="comment">#服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#开发环境</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#文件后缀名</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>@refreshScope注解   热更新自动刷新注解   在需要自动注入的地方使用</p>
</li>
</ol>
<p>nacos配置更改后，微服务可以实现热更新，方式：</p>
<ol>
<li>通过@value注解注入，结合@refreshScope来刷新</li>
<li>通过@ConfigurationProperties注入，自动刷新</li>
</ol>
<p>注意事项：</p>
<ul>
<li>不是所有的配置都适合放到配置中心，维护起来比较麻烦</li>
<li>建议将一些关键参数，需要运行时调整的参数放到nacos配置中心，一般都是自定义配置</li>
</ul>
<h3 id="多环境配置共享"><a href="#多环境配置共享" class="headerlink" title="多环境配置共享"></a>多环境配置共享</h3><p>微服务启动时会从nacos读取多个配置文件：</p>
<ul>
<li>[spring.application.name]-[spring.profiles.active].yaml，例如：userservice-dev.yaml</li>
<li>[spring.application.name.yaml].yaml，例如：userservice.yaml</li>
</ul>
<p>无论profile如何变化,[spring.application.name.yaml].yaml这个文件一定会加载，因此多环境共享配置可以写入这个文件</p>
<p>多种配置的优先级：</p>
<ul>
<li>服务名-profile.yaml &gt; 服务名称.yaml  &gt;  本地配置</li>
</ul>
<h3 id="Nacos集群搭建"><a href="#Nacos集群搭建" class="headerlink" title="Nacos集群搭建"></a>Nacos集群搭建</h3><p>nacos生产环境下一定要部署为集群状态</p>
<ol>
<li><p>配置nacos</p>
<p>配置三份nacos节点</p>
<ul>
<li><p>进入nacos的conf目录，修改配制文件cluster.conf.example，重命名为cluster.conf</p>
</li>
<li><p>添加内容：</p>
<p>127.0.0.1:8845</p>
<p>127.0.0.1:8846</p>
<p>127.0.0.1:8847</p>
</li>
</ul>
</li>
<li><p>将nacos文件夹复制三分，分别命名为：nacos1、nacos2、nacos3</p>
<ul>
<li><p>然后分别修改三个文件夹中的application.properties</p>
<p>server.port&#x3D;8845</p>
<p>server.port&#x3D;8846</p>
<p>server.port&#x3D;8847</p>
</li>
</ul>
</li>
<li><p>分别启动三个nacos节点</p>
</li>
<li><p>nginx反向代理</p>
<ul>
<li><p>修改conf&#x2F;nginx.conf文件，配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream nacos-cluster &#123;</span><br><span class="line">	server 127.0.0.1:8845;</span><br><span class="line">	server 127.0.0.1:8846;</span><br><span class="line">	server 127.0.0.1:8847;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">	listen	80;</span><br><span class="line">	server_name	localhost;</span><br><span class="line">	</span><br><span class="line">	location /nacos &#123;</span><br><span class="line">		proxy_pass http://nacos-cluster;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>将nacos中的连接数据库打开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.datasource.platform=mysql</span><br><span class="line">db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">db.user.0=root</span><br><span class="line">db.password.0=rose</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
</li>
</ol>
<h2 id="http客户端Feign"><a href="#http客户端Feign" class="headerlink" title="http客户端Feign"></a>http客户端Feign</h2><h3 id="RestTemplate方式调用存在的问题"><a href="#RestTemplate方式调用存在的问题" class="headerlink" title="RestTemplate方式调用存在的问题"></a>RestTemplate方式调用存在的问题</h3><p>先来看我们以前利用RestTemplate发起远程调用的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span><span class="string">&quot; http://userservice/user/&quot;</span>+order.getuserId();</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url,User.class)</span><br></pre></td></tr></table></figure>

<p>​	存在下面的问题：</p>
<ul>
<li>代码可读性差，编程体验不统一</li>
<li>参数复杂URL难以维护</li>
</ul>
<h3 id="Feign的介绍"><a href="#Feign的介绍" class="headerlink" title="Feign的介绍"></a>Feign的介绍</h3><p>Feign是一个声明式的http客户端，官方地址：<a href="http://github.com/OpenFeign/feign">http://github.com/OpenFeign/feign</a> 其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题</p>
<p>使用步骤：</p>
<ol>
<li><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入feign依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在order-service的启动类添加注解开启Feign的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写Feign客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="自定义Feign的配置"><a href="#自定义Feign的配置" class="headerlink" title="自定义Feign的配置"></a>自定义Feign的配置</h3><p>Feign运行自定义配置来覆盖默认配置，可以修改的配置如下</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>feign.Logger.Level</td>
<td>修改日志级别</td>
<td>包含四种不同的级别：NON、BASIC、HEADERS、FULL</td>
</tr>
<tr>
<td>feign.codec.Decoder</td>
<td>响应结果的解析器</td>
<td>http远程调用的结果做解析，例如解析json字符串为java对象</td>
</tr>
<tr>
<td>feign.codec.Encoder</td>
<td>请求参数编码</td>
<td>将请求参数编码，便于通过http请求发送</td>
</tr>
<tr>
<td>feign.Contract</td>
<td>支持的注解格式</td>
<td>默认是SpringMVC的注解</td>
</tr>
<tr>
<td>feign.Retryer</td>
<td>失败重试机制</td>
<td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td>
</tr>
</tbody></table>
<p>一般我们需要配置的就是日志级别</p>
<p>自定义Feign的配置有两种方式：</p>
<p>方式一：配置文件方式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">		<span class="attr">config:</span></span><br><span class="line">			<span class="attr">default:</span>  <span class="comment">#这里用default就是全局配置  </span></span><br><span class="line">				<span class="attr">loggerLevel:</span> <span class="string">Full</span>  <span class="comment">#日志级别</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">		<span class="attr">config:</span></span><br><span class="line">			<span class="attr">userservice:</span>  <span class="comment">#这里用userservice就是只有某个微服务配置</span></span><br><span class="line">				<span class="attr">loggerLevel:</span> <span class="string">Full</span>  <span class="comment">#日志级别</span></span><br></pre></td></tr></table></figure>

<p>方式二：Java代码方式，需要先声明一个bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignClientConfiguration</span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Logger.Level.BASIC;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>而后如果是全局配置，则把它放到@EnableFeignClient这个注解中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是局部配置，则把他放到@FeignClient这个注解中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@feignClient(value = &quot;userservice&quot;,configuration=FeignClientConfiguration.class)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Feign的性能优化"><a href="#Feign的性能优化" class="headerlink" title="Feign的性能优化"></a>Feign的性能优化</h3><p>Feign底层的客户端实现：</p>
<ul>
<li>URLConnection：默认实现，不支持连接池</li>
<li>Apache Httpclient:支持连接池</li>
<li>OKHTTP：支持连接池</li>
</ul>
<p>因此优化Feign的性能主要包括：</p>
<ol>
<li>使用连接池代替默认的URLConnection</li>
<li>日志级别，最好用basic或none</li>
</ol>
<p>步骤：</p>
<ol>
<li><p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入HttpClient依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Feign的最佳实践"><a href="#Feign的最佳实践" class="headerlink" title="Feign的最佳实践"></a>Feign的最佳实践</h3><h4 id="方式一（继承）："><a href="#方式一（继承）：" class="headerlink" title="方式一（继承）："></a>方式一（继承）：</h4><p>给消费者的FeignClient和提供者的controller定义统一的父接口作为标准</p>
<p>因为消费者的feignClient和提供者的controller的方法名和参数以及请求方式都相似，所以可以把他们抽取出来定义一个父类  让他们来继承 ，这样 他们就都不用写了。但这样他们的耦合性就高了</p>
<h4 id="方式二（抽取）："><a href="#方式二（抽取）：" class="headerlink" title="方式二（抽取）："></a>方式二（抽取）：</h4><p>将FeignCilent抽取为独立模块，并且把接口端的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用</p>
<p>因为服务的消费者用的userCilent有很多消费者在用，我们把userclient抽取出来（包括实体类，默认配置等），让消费者来医用依赖，然后远程调用服务的提供者。</p>
<h4 id="实现最佳实现方式二"><a href="#实现最佳实现方式二" class="headerlink" title="实现最佳实现方式二"></a>实现最佳实现方式二</h4><ol>
<li>首先创建一个module，命名为feign-api，然后引入feign的starter依赖</li>
<li>将order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中</li>
<li>在order-service中引入feign-api的依赖</li>
<li>修改order-service中的所有与上述三个组件有关的import部分，改成导入feign-api中的包</li>
</ol>
<p>当定义FeignClient不在SpringBootApplication的扫描包范围时，这些FeignClient无法使用。有两种解决方案：</p>
<ol>
<li><p>方式一：指定FeignClient所在包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages=&quot;cn.itcast.feign.clients&quot;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：指定FeignClient字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="GateWay网关"><a href="#GateWay网关" class="headerlink" title="GateWay网关"></a>GateWay网关</h2><p>为什么需要网关？</p>
<p>微服务先注册到nacos，微服务与微服务之间通过feign来调用，用户需要操作时直接发请求到微服务，但这时候就存在一个问题，我们的微服务就在那里让所有人访问这是不安全的，因为有些业务属于公司内部的不需要面向大众，所以就需要对用户的身份进行验证。所以gateway网关就是专门做这个的。验证完后是不是需要放行到微服务去那？所以网关还需要将请求转发到微服务，也就是服务路由，并且网关还做到了负载均衡，因为一个查询请求对应的微服务可能偶多个实例。网关还可以请求限流</p>
<h3 id="网关的功能："><a href="#网关的功能：" class="headerlink" title="网关的功能："></a>网关的功能：</h3><ul>
<li>身份验证和权限校验。</li>
<li>服务路由和负载均衡</li>
<li>请求限流</li>
</ul>
<h3 id="网关的技术实现"><a href="#网关的技术实现" class="headerlink" title="网关的技术实现"></a>网关的技术实现</h3><ul>
<li>gateway</li>
<li>zuul</li>
</ul>
<p>zuul是基于servlet的实现，属于阻塞式编程。而SpringcloudGateway是基于Spring5中提供的webFlux，属于响应式编程的实现，具备更好的性能。</p>
<h3 id="搭建网关服务"><a href="#搭建网关服务" class="headerlink" title="搭建网关服务"></a>搭建网关服务</h3><p>步骤：</p>
<ol>
<li><p>创建新的mouble，引入SpringCloudGateWay的依赖和nacos的服务发现依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos的服务发现依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--网关依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写路由配置及nacos地址</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span>  <span class="comment">#服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span>  <span class="comment">#nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment">#网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span>  <span class="comment">#路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span>  <span class="comment">#路由的目标地址，lb就是负载均衡  后面跟着服务名</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment">#路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment">#这是按照路径匹配 也就是/user/开头就符合要求</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://orderservice</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/order/**</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment">#网关端口</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>总结：</p>
<ol>
<li><p>创建项目，引入nacos服务发现和gateway依赖</p>
</li>
<li><p>配置application.yml，包括服务基本信息、nacos地址、路由</p>
<p>路由配置包括：</p>
<ul>
<li>路由id：路由的唯一标识</li>
<li>路由目标（uri）：路由的目标地址、http代表固定地址，lb代表根据服务名负载均衡</li>
<li>路由断言(prediscates):判断路由的规则</li>
<li>路由过滤器(filters):对请求或响应做处理</li>
</ul>
</li>
</ol>
<h3 id="路由断言工厂RoutePredicateFactory"><a href="#路由断言工厂RoutePredicateFactory" class="headerlink" title="路由断言工厂RoutePredicateFactory"></a>路由断言工厂RoutePredicateFactory</h3><p>spring提供了11种基本的predicate工厂：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>After</td>
<td>是某个时间点之后的请求</td>
<td>-Afer&#x3D;2023-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td>
</tr>
<tr>
<td>Before</td>
<td>是某个时间点之前的请求</td>
<td>-Afer&#x3D;2023-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td>
</tr>
<tr>
<td>Between</td>
<td>是某两个之间点之间的请求</td>
<td>-Between&#x3D;2023-01-20T17:42:47.789-07:00[America&#x2F;Denver],023-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td>
</tr>
<tr>
<td>Cookid</td>
<td>请求必须包含某些cookie</td>
<td>-Cookid&#x3D;chocolata,ch.p</td>
</tr>
<tr>
<td>Header</td>
<td>请求必须包含某些header</td>
<td>-Header&#x3D;X-Request-Id,\d+</td>
</tr>
<tr>
<td>Host</td>
<td>请求必须是访问某个host（域名）</td>
<td>-Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td>
</tr>
<tr>
<td>Method</td>
<td>请求方式必须是指定方式</td>
<td>-Method&#x3D;GET,POST</td>
</tr>
<tr>
<td>Path</td>
<td>请求路径必须符合指定规则</td>
<td>-Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td>
</tr>
<tr>
<td>Query</td>
<td>请求参数必须包含指定参数</td>
<td>-Query&#x3D;name,Jack或者-Query&#x3D;name</td>
</tr>
<tr>
<td>RemoteAddr</td>
<td>请求者的ip必须是指定范围</td>
<td>-ReomteAdr&#x3D;192.168.1.1&#x2F;24</td>
</tr>
<tr>
<td>Weight</td>
<td>权重处理</td>
<td></td>
</tr>
</tbody></table>
<h3 id="路由过滤器GatewayFilter"><a href="#路由过滤器GatewayFilter" class="headerlink" title="路由过滤器GatewayFilter"></a>路由过滤器GatewayFilter</h3><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p>
<p>spring提供了31种不同的路由过滤器工厂：看例如：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AddrequestHeader</td>
<td>给当前请求添加一个请求头</td>
</tr>
<tr>
<td>RemoveRequestHeader</td>
<td>移除请求中的一个请求头</td>
</tr>
<tr>
<td>AddResponseHeader</td>
<td>给响应结果中添加一个响应头</td>
</tr>
<tr>
<td>RemoveResponseHeader</td>
<td>从响应结果中移除一个响应头</td>
</tr>
<tr>
<td>RequestRateLimiter</td>
<td>限制请求的流量</td>
</tr>
</tbody></table>
<p>给所有进入userservice的请求添加一个请求头：Truth&#x3D;rosevvi fucking awesome!</p>
<p>实现方式：在gateway中修改application.yml文件，给userserivice的路由添加过滤器:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes:</span> <span class="comment">#网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span>  <span class="comment">#路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span>  <span class="comment">#路由的目标地址，lb就是负载均衡  后面跟着服务名</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment">#路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment">#这是按照路径匹配 也就是/user/开头就符合要求</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,rosevvi</span> <span class="string">is</span> <span class="string">fucking</span> <span class="string">rwesome!!!</span></span><br></pre></td></tr></table></figure>

<p>如果要对所有的路由都生效，则可以将过滤器工厂的default下。格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">      <span class="attr">routes:</span> <span class="comment">#网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span>  <span class="comment">#路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span>  <span class="comment">#路由的目标地址，lb就是负载均衡  后面跟着服务名</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment">#路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment">#这是按照路径匹配 也就是/user/开头就符合要求</span></span><br><span class="line"><span class="comment">#          filters:</span></span><br><span class="line"><span class="comment">#            - AddRequestHeader=Truth,rosevvi is fucking rwesome!!!</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://orderservice</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/order/**</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,rosevvi</span> <span class="string">is</span> <span class="string">fucking</span> <span class="string">rwesome!!!</span></span><br></pre></td></tr></table></figure>

<h3 id="全局过滤器GlobleFilter"><a href="#全局过滤器GlobleFilter" class="headerlink" title="全局过滤器GlobleFilter"></a>全局过滤器GlobleFilter</h3><p>全局过滤器的作用也是处理一切网关的请求和微服务响应，与fatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的。而GlobalFilter的逻辑需要自己写代码实现</p>
<p>定义方式是实现FlobalFilter接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置优先级  或者实现Ordered接口</span></span><br><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//1、获取请求参数</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="comment">//2、获取参数中的Authorization参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">auth</span> <span class="operator">=</span> request.getQueryParams().getFirst(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="comment">//3、判断参数值是否为admin</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(auth))&#123;</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4、拦截  设置状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="comment">//5、拦截请求</span></span><br><span class="line">        <span class="keyword">return</span>  exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过滤器的执行顺序"><a href="#过滤器的执行顺序" class="headerlink" title="过滤器的执行顺序"></a>过滤器的执行顺序</h4><ul>
<li>每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前。</li>
<li>GlobalFilter通过实现Order接口，或者添加@Order注解来指定order值，有我们自己指定</li>
<li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li>
<li>当过滤器的order值一样时，会按照defaultFilter&gt;路由过滤器&gt;GlobalFilter的顺序执行。</li>
</ul>
<h3 id="网关跨域问题处理"><a href="#网关跨域问题处理" class="headerlink" title="网关跨域问题处理"></a>网关跨域问题处理</h3><p>跨域：域名不一致就是跨域，主要包括</p>
<ul>
<li>域名不同：<a href="http://www.taobao.com和www.taobao.org和www.jd.com和miaosha.jd.com/">www.taobao.com和www.taobao.org和www.jd.com和miaosha.jd.com</a></li>
<li>域名相同，端口不容：localhost:8080和localhost:8081</li>
</ul>
<p>跨域问题：浏览器禁止请求的发起者与服务端跨域ajax请求，请求被浏览器拦截问题。</p>
<p>解决方案：CORS</p>
<p>网关处理跨域采用的同样是CORS方案，并且只需要简单配置即可实现：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment">#全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span>  <span class="comment">#解决options请求被拦截</span></span><br><span class="line">        <span class="attr">cors-configurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span> <span class="comment">#拦截那些请求</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span>  <span class="comment">#允许那些网站的跨域请求</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://www.leyou.com&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span>  <span class="comment">#允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment">#允许在请求头中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment">#是否允许携带cookid</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment">#这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure>

<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>项目部署的问题</p>
<p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p>
<ul>
<li>依赖关系复杂，容易出现兼容性问题</li>
<li>开发、测试、生产环境有差异</li>
</ul>
<p>Docker如何解决依赖的兼容问题的？</p>
<ul>
<li>将应用的libs（函数库）、Deps（依赖）、配置与应用一起打包</li>
<li>将每个应用放到一个隔离容器去运行，避免互相干扰</li>
</ul>
<p>Docker如何解决不同系统环境的问题？</p>
<ul>
<li>Docker将用户程序与所需要调用的系统（比如Centos）函数库一起打包，这样它只要基于linux内核就可以运行</li>
<li>Docker运行到不同操作系统时，直接基于打包的库函数，借助于操作系统的linux内核来运行</li>
</ul>
<h3 id="Docker和虚拟机的差异："><a href="#Docker和虚拟机的差异：" class="headerlink" title="Docker和虚拟机的差异："></a>Docker和虚拟机的差异：</h3><ul>
<li>docker是一个系统进程；虚拟机是在操作系统中的操作系统</li>
<li>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</li>
</ul>
<h3 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h3><p>镜像（Image）：Docker将应用程序以及其所需要的依赖、环境、配置等文件打包在一起，称为镜像。</p>
<p>容器（Container）：镜像中的应用程序运行后形成的进程就是容器，只是Docker会给容器做隔离，使其互相对外不可见。</p>
<p>DockerHub：DockerHub是一个Docker镜像的托管平台。这样的怕平台称为DockerRegistry。</p>
<p>Docker是一个CS架构的程序，由两部分组成：</p>
<ul>
<li>服务端（server):Docker守护进程，负责处理Docker指令，管理镜像、容器等</li>
<li>客户端（client）：通过命令或RestApi向Docker服务端发送指令。可以在本地或远程向服务器发送指令</li>
</ul>
<h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><h4 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">镜像命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁止开机启动防火墙</span></span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看防火墙状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动Docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker版本</span></span><br><span class="line">docker -v</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止docker 服务</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启docker 服务</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看本地镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像 没有版本 默认最新版</span></span><br><span class="line">docker pull nginx:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送镜像</span> </span><br><span class="line">docker push</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除一个本地镜像</span></span><br><span class="line">docker rmi nginx:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看帮助</span></span><br><span class="line">docker save --help</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">利用dockers save将nginx镜像导出到磁盘，然后再通过load加载回来  docker save [options] image [image]...</span></span><br><span class="line">docker save -o nginx.tar nginx:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">利用load加载镜像</span></span><br><span class="line">docker load -i nginx.tar</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建镜像  自定义镜像  -t指定dockerfile所在目录 空格点.</span></span><br><span class="line">docker build -t</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器常用命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行  --name：给容器起名字   -p：将宿主机端口与容器端口映射，冒号左边是宿主机端口，右侧是容器端口  80:80  -d：后台运行容器 nginx：基于nginx镜像创建的</span></span><br><span class="line">docker run  --name containerName -p 80:80 -d nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂停</span></span><br><span class="line">docker pause</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始</span></span><br><span class="line">docker unpause</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止</span></span><br><span class="line">docker stop</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始</span></span><br><span class="line">docker start</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有运行的容器及状态  -a查看所有状态的容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器运行日志 docker logs [name] -f   -f：持续输出日志</span></span><br><span class="line">docker logs mn</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器执行命令   要执行的命令通常为bash</span></span><br><span class="line">docker exec -it [容器名][要执行的命令]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除指定容器 -f强制删除运行中的容器</span></span><br><span class="line">docker rm -f</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数据卷命令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数据卷操作命令的基本语法</span></span><br><span class="line">docker volume [COMMAND]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建一个volume</span></span><br><span class="line">docker volume create</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示一个或多个volume的信息</span></span><br><span class="line">docker volume inspect</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出所有的volume</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除未使用的volume</span></span><br><span class="line">docker volume prune</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除一个或多个指定的volume</span></span><br><span class="line">docker volume rm</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数据卷挂载</span></span><br><span class="line">docker run --name mn -v html:/root/html -p 8080:80 nginx</span><br></pre></td></tr></table></figure>





<h4 id="1-CentOs安装Docker"><a href="#1-CentOs安装Docker" class="headerlink" title="1.CentOs安装Docker"></a>1.CentOs安装Docker</h4><p>DockerCE支持64位版本的Centos7，并且要求内核版本不低于3.10，Centos7满足最低内核要求，所以我们在Centos7上安装Docker</p>
<h4 id="1-1卸载（可选）"><a href="#1-1卸载（可选）" class="headerlink" title="1.1卸载（可选）"></a>1.1卸载（可选）</h4><p>如果之间安装过旧版本的Docker，可以使用下面命令卸载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum  remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest=logrotate \</span><br><span class="line">    docker-logroate \</span><br><span class="line">    docker-selinux \</span><br><span class="line">    docker-engine-selinux \</span><br><span class="line">    docker-enfine \</span><br><span class="line">    docker -ce </span><br></pre></td></tr></table></figure>

<h4 id="1-2-安装Docker"><a href="#1-2-安装Docker" class="headerlink" title="1.2 安装Docker"></a>1.2 安装Docker</h4><p>首先要联网虚拟机，安装yum工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">    device=mapper-persistent-data \</span><br><span class="line">    lvn2 --skip-broken\</span><br></pre></td></tr></table></figure>

<p>更新本地镜像源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置Docker镜像源</span></span><br><span class="line">yum-config-manger \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27;</span><br><span class="line">/etc/yum.repos.d/docker-ce.repo</span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>

<p>然后输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure>

<p>稍等就安装完成了</p>
<h4 id="1-3-启动docker"><a href="#1-3-启动docker" class="headerlink" title="1.3 启动docker"></a>1.3 启动docker</h4><p>Docker应用需要用到各种端口，逐一去修改防护墙设置非常麻烦，建议关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁止开机启动防火墙</span></span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看防火墙状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动Docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker版本</span></span><br><span class="line">docker -v</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止docker 服务</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启docker 服务</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-4-配置镜像"><a href="#1-4-配置镜像" class="headerlink" title="1.4 配置镜像"></a>1.4 配置镜像</h4><p>docker官方镜像仓库网速较差，我们需要设置国内镜像</p>
<p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://u2fv9qvc.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="容器练习"><a href="#容器练习" class="headerlink" title="容器练习"></a>容器练习</h3><p>进入nginx容器，修改html文件内容，添加“船只教育观影你”</p>
<ol>
<li><p>进入容器。进入我们刚创建的nginx的容器命令为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mn bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li>docker exec：进入容器内部，执行一个命令</li>
<li>-it：给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</li>
<li>mn：要进入的容器的名称</li>
<li>bash：进入容器后执行的命令，bash是一个linux终端交互命令</li>
</ul>
</li>
</ol>
<h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>数据卷（volume）是一个虚拟目录，指向宿主机文件系统中的某个目录（&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes），创建一个数据卷html那么他就会创建&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html</p>
<p>数据卷操作命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数据卷操作命令的基本语法</span></span><br><span class="line">docker volume [COMMAND]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建一个volume</span></span><br><span class="line">docker volume create [name]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示一个或多个volume的信息</span></span><br><span class="line">docker volume inspect</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出所有的volume</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除未使用的volume</span></span><br><span class="line">docker volume prune</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除一个或多个指定的volume</span></span><br><span class="line">docker volume rm</span><br></pre></td></tr></table></figure>

<h3 id="数据卷挂载"><a href="#数据卷挂载" class="headerlink" title="数据卷挂载"></a>数据卷挂载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-v 前半部分是数据卷，后半部分是容器内目录</span></span><br><span class="line">docker run --name mn -v html:/root/html -p 8080:80 nginx</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<p>需求说明:上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。提示:运行容器时使用-v参数挂载数据卷</p>
<p>步骤:</p>
<ol>
<li><p>创建容器并挂载数据卷到容器内的HTML目录、</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建名为html的数据卷</span></span><br><span class="line">docker valume html</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建容器并挂载数据卷到容器内的html目录</span></span><br><span class="line">docker run --name mn -p 80:80 -v </span><br><span class="line">html:/usr/share/nginx/html -d nginx</span><br></pre></td></tr></table></figure>


</li>
<li><p>进入html数据卷所在位置，并修改HTML内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看数据卷的位置</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">计入该目录</span> </span><br><span class="line">cd </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改文件</span></span><br><span class="line">vi</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="宿主机目录挂载"><a href="#宿主机目录挂载" class="headerlink" title="宿主机目录挂载"></a>宿主机目录挂载</h4><p>宿主机目录可以直接挂载到容器</p>
<ul>
<li>-v [宿主机目录]:[容器内目录]</li>
<li>-v[宿主机文件]:[容器内文件]</li>
</ul>
<p>实现思路如下:</p>
<ol>
<li><p>在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p>
</li>
<li><p>创建目录&#x2F;tmp&#x2F;myql&#x2F;data,</p>
</li>
<li><p>创建目录&#x2F;tmp&#x2F;myql&#x2F;conf，将课前资料提供的hmy.cnf文件上传到&#x2F;tmp&#x2F;myql&#x2F;conf4．</p>
</li>
<li><p>去DockerHub查阅资料，创建并运行MySQL容器，要求:</p>
<ul>
<li>挂载&#x2F;tmp&#x2F;myql&#x2F;data到mysql容器内数据存储目录</li>
<li>挂载&#x2F;tmp&#x2F;myql&#x2F;conf&#x2F;hmy.cnf到mysql容器的配置文件</li>
<li>设置MySQL密码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">	--name mysql \</span><br><span class="line">	-e MYSAL_ROOT_PASSWORD=123 \</span><br><span class="line">	-p 3306:3306 \</span><br><span class="line">	-v /tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf \</span><br><span class="line">	-v /tmp/mysql/data:/var/lib/musql</span><br><span class="line">	-d \</span><br><span class="line">	mysql:5.7.25</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总结：</p>
<ol>
<li>docker run的命令中通过-v参数挂载文件或目录到容器中：<ul>
<li>-v volume 名称:容器内目录</li>
<li>-v 宿主机文件:容器内文件</li>
<li>-v 宿主机目录:容器内目录</li>
</ul>
</li>
<li>数据卷挂载与目录直接挂载的区别：<ul>
<li>数据卷挂载耦合度低，由docker来管理，但是目录较深，不好找</li>
<li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li>
</ul>
</li>
</ol>
<h3 id="DockerFile自定义镜像"><a href="#DockerFile自定义镜像" class="headerlink" title="DockerFile自定义镜像"></a>DockerFile自定义镜像</h3><h4 id="镜像结构："><a href="#镜像结构：" class="headerlink" title="镜像结构："></a>镜像结构：</h4><p>镜像是一个分层结构，每一层称为一个layer：</p>
<ul>
<li>BaseImage层：包含基本的系统函数库、环境变量、文件系统</li>
<li>Entrypoint：入口，是镜像中应用启动的命令</li>
<li>其他：在BaseImage基础上添加依赖、安装程序、完成整个应用的安装和配置</li>
</ul>
<h4 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h4><p>DockerFile就是一个文本文件，其中包含一个个的指令，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层layer</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>指定基础镜像</td>
<td>FROM centos:6</td>
</tr>
<tr>
<td>ENV</td>
<td>设置环境变量，可在后面指令使用</td>
<td>ENV key value</td>
</tr>
<tr>
<td>COPY</td>
<td>拷贝本地文件到镜像的指定目录</td>
<td>COPY .&#x2F;mysql-2.7.rpm &#x2F;tmp</td>
</tr>
<tr>
<td>RUN</td>
<td>执行linux的shell命令，一般是安装过程的命令</td>
<td>RUN yum  install gcc</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>指定容器运行时监听的端口，是给镜像使用者看的</td>
<td>EXPOSE 8080</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>镜像中应用的启动命令，容器运行时调用</td>
<td>ENTRYPOINT java -jar  xx.jar</td>
</tr>
</tbody></table>
<p>案例：</p>
<p>基于Ubuntu镜像构建一个新镜像，运行一个java项目<br>步骤1∶新建一个空文件夹docker-demo<br>步骤2:拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录<br>步骤3:拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录<br>步骤4:拷贝课前资料提供的Dockerfile到docker-demo这个目录<br>步骤5:进入docker-demo<br>步骤6:运行命令:</p>
<p>DokerFile示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定基础镜像</span></span><br><span class="line">FROM centos:6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置环境变量，JDK的安装目录</span></span><br><span class="line">ENV JAVA_DIR=/usr/local</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝jdk和java项目的包</span></span><br><span class="line">COPY ./jdk8.tar.gz $JAVA_DIR/</span><br><span class="line">COPY ./docker-demo.jar /tmp/app.jar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装JDK</span></span><br><span class="line">Run cd $JAVA_DIR \</span><br><span class="line">	&amp;&amp; tar -xf ./jdk8.tar.gz \</span><br><span class="line">	&amp;&amp; mv ./jdk1.8.0_144 ./java8</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置环境变量</span></span><br><span class="line">ENV JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line">ENV PATH=$PATH:$JAVA_DIR/bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">暴露端口</span></span><br><span class="line">EXPOSE 8090</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">入口 Java项目的启动命令</span></span><br><span class="line">ENTRYPOINT java -jar .tmp/app.jar</span><br></pre></td></tr></table></figure>

<p>现在有人把安装jdk的步骤构建成了镜像，我们可以利用java:8-alpine镜像来构建自己的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定基础镜像</span></span><br><span class="line">FROM java:8-alpine</span><br><span class="line">COPY ./docker-demo.jar /tmp/app.jar</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">暴露端口</span></span><br><span class="line">EXPOSE 8090</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">入口 Java项目的启动命令</span></span><br><span class="line">ENTRYPOINT java -jar .tmp/app.jar</span><br></pre></td></tr></table></figure>

<h4 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h4><ul>
<li>DockerCompose可以基于Compose文件帮我们快速的部署分布式应用，而无需上搜东一个个创建和运行容器</li>
<li>Compose文件是一个文本文件，可以通过指令定义集群中的每一个容器如何运行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version: &quot;3.8&quot;</span><br><span class="line">services:</span><br><span class="line">	mysql: #容器名称</span><br><span class="line">		image: mysql:5.7.25  #镜像名称</span><br><span class="line">		environment: </span><br><span class="line">			MYSQL_ROOT_PASSWORD:123 #设置密码</span><br><span class="line">		volumes: #数据卷</span><br><span class="line">			- /tmp/mysql/data:/var/lib/mysql</span><br><span class="line">			- /tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf</span><br><span class="line">	web: </span><br><span class="line">		build: . #构建 . 代表从当前目录构建镜像</span><br><span class="line">		ports:</span><br><span class="line">		 - 8090 : 8090</span><br></pre></td></tr></table></figure>



<h2 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h2><p>同步调用：你个妹子打视频电话</p>
<p>异步调用：你和19个妹子发微信消息</p>
<p>同步调用的问题：微服务之间基于Feign的调用就属于同步方式，存在一些问题</p>
<p>同步调用的优点：</p>
<ul>
<li>时效性强，可以立即得到结果</li>
</ul>
<p>同步调用的问题：</p>
<ul>
<li>耦合度高</li>
<li>性能和吞吐能力下降</li>
<li>有额外的资源消耗</li>
<li>有级联失败问题</li>
</ul>
<p>异步调用：异步调用常见实现就是事件驱动模式</p>
<p>异步通讯优势：</p>
<ul>
<li>服务解耦</li>
<li>吞吐量提升</li>
<li>故障隔离</li>
<li>流量削峰</li>
</ul>
<p>异步通信的缺点：</p>
<ul>
<li>依赖于Broker的可靠性、安全性、吞吐能力</li>
<li>架构复杂了，业务没有明显的流程线，不好跟踪管理</li>
</ul>
<p>什么是MQ</p>
<p>MQ（MessageQueue），中文是消息队列，字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p>
<table>
<thead>
<tr>
<th></th>
<th>RabbitMQ</th>
<th>ACtiveMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td>公司&#x2F;社区</td>
<td>Rabbit</td>
<td>Apache</td>
<td>阿里</td>
<td>Apache</td>
</tr>
<tr>
<td>开发语言</td>
<td>Erlang</td>
<td>Java</td>
<td>Java</td>
<td>Scala&amp;Java</td>
</tr>
<tr>
<td>协议支持</td>
<td>AMQP、XMPP、SMTP、STOMP</td>
<td>OpenWire,STOMP,REST,XNPP,AMQP</td>
<td>自定义协议</td>
<td>自定义协议</td>
</tr>
<tr>
<td>可用性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>一般</td>
<td>差</td>
<td>高</td>
<td>非常高</td>
</tr>
<tr>
<td>消息延迟</td>
<td>微秒级</td>
<td>毫秒级</td>
<td>毫秒级</td>
<td>毫秒以内</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>一般</td>
</tr>
</tbody></table>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h4><p>下载镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<p>执行下面命令来运行MQ容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">	-e RABBITMQ_DEFAULT_USER=rosevvi \ #设置环境变量</span><br><span class="line">	-e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line">	--name mq \  #起名</span><br><span class="line">	--hostname mq1 \ #配置主机名</span><br><span class="line">	-p 15672:15672 \ #端口映射 管理平台的端口</span><br><span class="line">	-p 5672:5672 \ #消息通信的端口</span><br><span class="line">	-d \</span><br><span class="line">	rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<p>RabbitMQ的几个概念：</p>
<ul>
<li>channel：操作MQ的工具</li>
<li>exchange：路有消息到队列中</li>
<li>queue：缓存消息</li>
<li>virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组</li>
</ul>
<h4 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h4><p>MQ的官方文档中给出了5个MQ的demo示例，对应了集中不同的用法：</p>
<ul>
<li>基本消息队列（BasicQueue）</li>
<li>工作消息队列（WorkQueue）</li>
<li>发布订阅（Publish、Subscribe），有根据交换机类型不同分为三种：<ul>
<li>FanoutExChange：广播</li>
<li>DirectExchange：路由</li>
<li>TopicExchange：主题</li>
</ul>
</li>
</ul>
<p>基本消息队列的消息发送流程：</p>
<ol>
<li>建立连接connection</li>
<li>创建channel</li>
<li>利用channel声明队列</li>
<li>利用channel向队列发送消息</li>
</ol>
<p>基本消息队列的消息接收流程：</p>
<ol>
<li>建立connection</li>
<li>创建channel</li>
<li>利用channel声明队列</li>
<li>定义consumer的消费行为handleDelivery（）</li>
<li>利用channel将消费者与队列绑定</li>
</ol>
<h3 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h3><p>Advanced Message Queuing Protocol，是用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求。</p>
<p>SpringAMQP 是基于AMQP协议定义的一套API规范，提供了模板来发送和接收消息。包含两部分，其中spring-amop是基础抽象，spring-rabbit是底层的默认实现。</p>
<p>案例：利用SpringAMQP实现helloworld中的基础消息队列功能</p>
<p>流程：</p>
<ol>
<li>在父工程中引入spring-amqp的依赖</li>
<li>在publisher服务中利用RabbitTemplate发送消息到simple.queue这个队列</li>
<li>在consumer服务中编写消费逻辑，绑定simple.queue 这个队列</li>
</ol>
<p>步骤一：</p>
<ol>
<li><p>引入AMQP依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>步骤二：</p>
<ol>
<li><p>在publisher服务中编写application.yml，添加mq连接信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">43.143</span><span class="number">.237</span><span class="number">.123</span> <span class="comment">#rabbitMQ的ip地址</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment">#端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span>  <span class="comment">#虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">rosevvi</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>在publisher服务中新建一个测试类，编写测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublisherTest</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplatel;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRabbitTemplatel</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">queuename</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello rosevvi&quot;</span>;</span><br><span class="line">    rabbitTemplatel.convertAndSend(queuename,message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>步骤三：在consumer中编写消费逻辑，监听simple.queue</p>
<ol>
<li><p>在consumer服务中编写application.yml，添加mq连接信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">43.143</span><span class="number">.237</span><span class="number">.123</span> <span class="comment">#rabbitMQ的ip地址</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment">#端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span>  <span class="comment">#虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">rosevvi</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在consumer服务中新建一个类，编写消费逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.springframework.amqp.rabbit.annotation.RabbitListener(queues = <span class="string">&quot;simple.queue&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerSimpleQueueMessage</span><span class="params">(String  msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者收到消息:&#123;&quot;</span>+msg+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="WorkQueue工作队列"><a href="#WorkQueue工作队列" class="headerlink" title="WorkQueue工作队列"></a>WorkQueue工作队列</h3><p>Workqueue，工作队列，可以提高消息处理速度，避免队列消息堆积</p>
<p>案例：模拟WorkQueue，实现一个队列绑定多个消费者</p>
<p>基本思路：</p>
<ol>
<li>在publisher服务中定义测试方法，每秒产生50条消息，发送到simple.queue</li>
<li>在consumer服务中定义两个消息监听者，都监听simple.queue</li>
<li>消费者1每秒处理50条消息，消费者2每秒处理10条消息。</li>
</ol>
<p>消费预取限制：修改application.yml文件，设置preFetch这个值，可以控制预取消息的上限.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">43.143</span><span class="number">.237</span><span class="number">.123</span> <span class="comment">#rabbitMQ的ip地址</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment">#端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span>  <span class="comment">#虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">rosevvi</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>发布、订阅</p>
<p>发布订阅模式与之前案例的区别就是允许将同一消息发送给多个消费者。实现方式是加入了exchange（交换机）</p>
<p>常见exchange类型包括：</p>
<ul>
<li>Fanout：广播</li>
<li>Direct：路由</li>
<li>Topic：话题</li>
</ul>
<h3 id="发布订阅-FanoutExchange"><a href="#发布订阅-FanoutExchange" class="headerlink" title="发布订阅-FanoutExchange"></a>发布订阅-FanoutExchange</h3><p>FanoutExchange会将收到的消息路由到每一个跟其绑定的queue</p>
<p>案例：</p>
<ol>
<li>在consumer服务中，利用代码声明队列、交换机，并将两者绑定。</li>
<li>在consumer服务中，编写两个消费者方法，分别监听fanout.queue1和fanout.queue2</li>
<li>在publisher中编写测试方法，向rosevvi.fanout发送消息</li>
</ol>
<p>步骤：</p>
<ol>
<li><p>在consumer服务声明Exchange、Queue、Binding</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">//定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;rosevvi.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义队列1</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;rosevvi.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定队列1和交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue queue1,FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义队列2</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;rosevvi.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定队列2和交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue queue2,FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>在consumer服务声明两个消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.amqp.rabbit.annotation.RabbitListener(queues = <span class="string">&quot;rosevvi.queue1&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerFanoutMessage1</span><span class="params">(String  msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1收到Fanout消息:&#123;&quot;</span>+msg+<span class="string">&quot;&#125;&quot;</span>+ LocalDateTime.now());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@org</span>.springframework.amqp.rabbit.annotation.RabbitListener(queues = <span class="string">&quot;rosevvi.queue2&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerFanoutMessage2</span><span class="params">(String  msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2收到Fanout消息:&#123;&quot;</span>+msg+<span class="string">&quot;&#125;&quot;</span>+LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在publisher服务发送消息到FanoutExchange</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fanOutExchangeTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//交换机名字</span></span><br><span class="line">    String name= <span class="string">&quot;rosevvi.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">//消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;rosevvi,Hello&quot;</span>;</span><br><span class="line">   </span><br><span class="line">    rabbitTemplatel.convertAndSend(name,<span class="string">&quot;&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>交换机的作用是什么：</p>
<ul>
<li>接收publisher发送的消息</li>
<li>将消息按照规则路由到与之绑定的队列</li>
<li>不能缓存消息、路由失败消息丢失</li>
<li>FanoutExchange会将消息路由到每个绑定的队列</li>
</ul>
<p>声明队列、交换机、绑定关系的bean是什么：</p>
<ol>
<li>Queue</li>
<li>FanoutExchange</li>
<li>Binding</li>
</ol>
<h3 id="发布订阅-DirectExchange"><a href="#发布订阅-DirectExchange" class="headerlink" title="发布订阅-DirectExchange"></a>发布订阅-DirectExchange</h3><p>DirectExchange会将接收到的消息根据规则路由到指定的Queue，因此称为路由模式（routes）</p>
<ul>
<li>每一个Queue都与Exchange设置一个BindingKey</li>
<li>发布者发送消息时，指定消息的RoutingKey</li>
<li>Exchange将消息路由到BindingKey与消息RoutingKey一致的队列</li>
</ul>
<p>案例：利用SpringAMQP演示DirectExchange的使用</p>
<p>实现思路：</p>
<ol>
<li>利用@RabbitListener声明Exchange、Queue、RountingKey</li>
<li>在Consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</li>
<li>在publisher中编写测试方法，向rosevvi.direct发送消息</li>
</ol>
<p>步骤1：在consumer服务声明Exchange、Queue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(&quot;rosevvi.direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &quot;rosevvi.direct&quot;,type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">        key = &#123;&quot;red&quot;,&quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerDirectMessage2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2收到Direct消息:&#123;&quot;</span>+msg+<span class="string">&quot;&#125;&quot;</span>+LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>描述下Direct交换机与Fanout交换机的差异？</p>
<ul>
<li>Fanout交换机将消息路由给每一个与之绑定的队列</li>
<li>Direct交换机根据RoutingKey判断路由给那个队列</li>
<li>如果多个队列具有相同的RoutingKey，则于Fanout功能相似</li>
</ul>
<p>基于@RabbitListener注解声明队列和交换机有那些常见注解？</p>
<ul>
<li>@Queue</li>
<li>@Exchange</li>
</ul>
<h3 id="发布订阅-TopicExchange"><a href="#发布订阅-TopicExchange" class="headerlink" title="发布订阅-TopicExchange"></a>发布订阅-TopicExchange</h3><p>TopicExchange与DirectExchange类似，区别在于routingKey必须是多个单词的列表，并且以     .         分割</p>
<p>Queue与Exchange指定BindingKey时可以使用通配符：</p>
<ul>
<li>#：代指0个或多个单词</li>
<li>*：代指一个单词</li>
</ul>
<p>案例：利用SpringAMQP演示TopicExchange的使用</p>
<p>实现思路如下：</p>
<ol>
<li>并利用@RabbitListener声明Exchange、Queue、RoutingKey</li>
<li>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</li>
<li>在publisher中编写测试方法，向itcast.topic发送消息</li>
</ol>
<p>步骤1：在xonsumer服务声明Exchange、Queue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;rosevvi.topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;rosevvi.topic&quot;,type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">        key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerTopicMessage2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2收到Topic消息:&#123;&quot;</span>+msg+<span class="string">&quot;&#125;&quot;</span>+LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h3><p>案例：测试发送Object类型消息</p>
<p>说明：在SpringAMQP的发送方法中，接收消息的类型时object，也就是说我们可以发送任意对象类型的消息，SpringAMQP会帮我们序列化为字节后发送。</p>
<p>Spring的消息对象处理是由MessageConverter来处理的。而默认实现是SimpleMessageConverter，基于JDK的ObjectOutputStream完成序列化。</p>
<p>如我要修改只需要定义一个MessageConverter类型的Bean即可。推荐使用Json方式序列化，步骤如下：</p>
<ol>
<li><p>在publisher服务引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在publisher服务声明MessageConverter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>SpringAMQP中消息的序列化和反序列化是怎么实现的？</p>
<ul>
<li>利用MessageConverter实现的，默认是JDK的序列化</li>
<li>注意发送方与接收方必须使用相同的MessageConverter</li>
</ul>
<h2 id="分布式搜索ElasticSearch"><a href="#分布式搜索ElasticSearch" class="headerlink" title="分布式搜索ElasticSearch"></a>分布式搜索ElasticSearch</h2><p>什么是elasticsearch</p>
<ul>
<li>elasticsearch是一款非常强大的开源搜索引擎，可以帮助我们从海量数据中快速找到需要的内容。可以用来实现搜索、日志统计、分析、系统监控等功能。</li>
</ul>
<p>什么是Elastic Stack（ELK）？</p>
<ol>
<li>是以Elasticsearch为核心的技术栈，包括beats、logstash、kibana、elasticsearch</li>
</ol>
<p>什么是Lucene？</p>
<ul>
<li>是Apache的开源搜索引擎类库，提供了搜索引擎的核心API</li>
</ul>
<h3 id="正向索引和倒排索引"><a href="#正向索引和倒排索引" class="headerlink" title="正向索引和倒排索引"></a>正向索引和倒排索引</h3><p>传统数据库（Mysql）采用正向索引，例如id自增利用id创建索引。</p>
<p>elasticsearch采用倒排索引：</p>
<ul>
<li>文档（document）：每条数据就是一个文档</li>
<li>词条（term）：文档按照语义分成的词语</li>
</ul>
<p>比如：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>title</th>
<th>price</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>小米手机</td>
<td>3499</td>
</tr>
<tr>
<td>2</td>
<td>华为手机</td>
<td>4999</td>
</tr>
<tr>
<td>3</td>
<td>华为小米充电器</td>
<td>49</td>
</tr>
<tr>
<td>4</td>
<td>小米手环</td>
<td>299</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>词条（term）</th>
<th>文档id</th>
</tr>
</thead>
<tbody><tr>
<td>小米</td>
<td>1，3，4</td>
</tr>
<tr>
<td>手机</td>
<td>1，2</td>
</tr>
<tr>
<td>华为</td>
<td>2，3</td>
</tr>
<tr>
<td>充电器</td>
<td>3</td>
</tr>
<tr>
<td>手环</td>
<td>4</td>
</tr>
</tbody></table>
<p>搜索时“华为手机”，会将华为手机进行分词，得到“华为”，“手机”两个词条，再利用词条去搜索得当文档id</p>
<p>总结：</p>
<p>什么是文档和词条？</p>
<ul>
<li>每一条数据就是一个文档</li>
<li>对文档中的内容分析，得到的词语就是词条</li>
</ul>
<p>什么是正向索引？</p>
<ul>
<li>基于文档id创建索引。查询词条时必须先找到文档，而后判断是否包含词条</li>
</ul>
<p>什么是倒排索引？</p>
<ul>
<li>对文档内容进行分词，对词条创建索引，并记录词条所在文档的信息。查询时现根据词条查询到文档id，而后获取到文档。</li>
</ul>
<p>文档：elasticsearch是面向文档存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为json格式后存储再elasticsearch中。</p>
<p>索引（index）：相同类型的文档的集合</p>
<p>映射（mapping）：索引中文档的字段约束信息，类似表的结构约束</p>
<p>概念对比：</p>
<table>
<thead>
<tr>
<th>mysql</th>
<th>elasticsearch</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Table</td>
<td>Index</td>
<td>索引（index），就是文档的集合，类似数据库的表（table）</td>
</tr>
<tr>
<td>Row</td>
<td>Document</td>
<td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是json格式</td>
</tr>
<tr>
<td>Column</td>
<td>Field</td>
<td>字段（Field），就是json文档中的字段，类似数据库中的列（Column）</td>
</tr>
<tr>
<td>Schema</td>
<td>Mapping</td>
<td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td>
</tr>
<tr>
<td>Sql</td>
<td>Dsl</td>
<td>Dsl是一个elasticsearch提供的json风格的请求语句，用来操作elasticsearch，实现FRUD</td>
</tr>
</tbody></table>
<p>架构</p>
<p>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</p>
<p>ElasticSearch：擅长海量数据的搜索、分析、计算</p>
<h3 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h3><p>单点部署</p>
<p>创建网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create es-net</span><br></pre></td></tr></table></figure>

<p>加载镜像</p>
<p>这里采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。不建议自己pull，建议上传到虚拟机后，自行加载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker load -i es.tar</span><br></pre></td></tr></table></figure>

<p>同理kibana的tar包也需要这样做</p>
<p>运行：运行docker命令，部署单点es：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">	--name es \</span><br><span class="line">	-e &quot;ES_$JAVA_OPTS=-Xms512m -Xms512m&quot; \</span><br><span class="line">	-e &quot;discovery.type=single-node&quot; \</span><br><span class="line">	-v es-data:/usr/share/elasticsearch/date \</span><br><span class="line">	-v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">	--privileged \</span><br><span class="line">	--network es-net \</span><br><span class="line">	-p 9200:9200 \ #暴露再http协议的端口</span><br><span class="line">	-p 9300:9300 \ #es容器各个节点之间互联的端口</span><br><span class="line">elasticsearch:7.12.1</span><br></pre></td></tr></table></figure>

<p>命令解释：</p>
<ul>
<li>-e  “cluster.name&#x3D;es-docker-cluster”:设置集群名称</li>
<li>-e “http.host&#x3D;0.0.0.0”:监听的地址，可以外网访问</li>
<li>-e “ES_JAVA_OPTS&#x3D;-Xms512m -Xmx512m” :内存大小</li>
<li>-e “discovery.type&#x3D;single-node” :非集群模式</li>
<li>-v es-data:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;date : 挂载逻辑卷，绑定es的数据目录</li>
<li>-v es-data:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins: 挂载逻辑卷，绑定es的插件目录</li>
<li>–privileged :授予逻辑卷访问权</li>
<li>–network es-net:加入一个名为es-net的网络中</li>
<li>-p 9200:9200:端口映射配置</li>
</ul>
<h3 id="部署kibana"><a href="#部署kibana" class="headerlink" title="部署kibana"></a>部署kibana</h3><p>kibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">	--name kibana \</span><br><span class="line">	-e ELASTICSEARCH_HOSTS=http://es:9200 \</span><br><span class="line">	--network=es-net \</span><br><span class="line">	-p 5601:5601 \</span><br><span class="line">kibana:7.12.1</span><br></pre></td></tr></table></figure>

<ul>
<li>–network es-net:加入一个名为es-net的网络中，与elasticsearch在同一个网络中</li>
<li>-e ELASTICSEARCH_HOSTS&#x3D;<a href="http://es:9200:设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch">http://es:9200:设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch</a></li>
<li>-p 5601:5601:端口映射配置</li>
</ul>
<h3 id="安装IK分词器"><a href="#安装IK分词器" class="headerlink" title="安装IK分词器"></a>安装IK分词器</h3><p>es再创建倒排索引时需要对文档分词；再搜索时，需要对用户输入内容分词。但默认的分词规则对中文处理并不友好，我们再kibnana的DevTools中测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line">&#123;</span><br><span class="line">	&quot;analyzer&quot;:&quot;standard&quot;,</span><br><span class="line">	&quot;text&quot;:&quot;黑马程序员学习java太棒了&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语法说明：</p>
<ul>
<li>POST：请求方式</li>
<li>&#x2F; _analyze：请求路径，这里省略了<a href="http://192.168.150.101:9200，有kibana帮我们补充">http://192.168.150.101:9200，有kibana帮我们补充</a></li>
<li>请求参数，json风格：<ul>
<li>analyzer：分词器类型，这里是默认的standard分词器</li>
<li>text：要分词的内容</li>
</ul>
</li>
</ul>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在线：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器内部</span></span><br><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在线下载并安装</span></span><br><span class="line">./bin/elasticsearch-plugin install</span><br><span class="line">https://github.com/medcl/elasticsearch-analysis-ik/release/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出</span></span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure>

<p>离线：</p>
<p>安装插件需要指导elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticearch的数据卷目录，通过下面命令查看：</p>
<ol>
<li><pre><code class="shell">docker volume inspect es-plugins
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 解压分词器安装包，重命名为ik</span><br><span class="line"></span><br><span class="line">3. 上传到es容器的插件数据卷中，也就是/var/lib/docker/volumes/es-plugins/_data;</span><br><span class="line"></span><br><span class="line">4. 重启容器</span><br><span class="line"></span><br><span class="line">   ```shell</span><br><span class="line">   #重启容器</span><br><span class="line">   docker restart es</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看es日志</span></span><br><span class="line">docker logs -f es</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>测试：ik分词器包含两种模式</p>
<ul>
<li>ik_smart：最少切分</li>
<li>ik_max_word：最细切分</li>
</ul>
</li>
</ol>
<h3 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h3><h4 id="扩展词库-停用词库"><a href="#扩展词库-停用词库" class="headerlink" title="扩展词库-停用词库"></a>扩展词库-停用词库</h4><p>要扩展分词器的词库，只需要修改一个ik分词器目录中的config目录中的IKAnalyzer.cfg.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF_8&quot;</span>?&gt;</span></span><br><span class="line">&lt;! DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">commemt</span>&gt;</span>Ik analyzer 扩展配置 <span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--用户可以在这里配置自己的扩展字典***添加扩展字典--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.did<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用户可以在这里配置自己的扩展停用字典***添加停用词字典--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span>stopwords.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="索引库"><a href="#索引库" class="headerlink" title="索引库"></a>索引库</h3><h4 id="mapping属性"><a href="#mapping属性" class="headerlink" title="mapping属性"></a>mapping属性</h4><p>mapping属性时是对索引库中文档的约束，常见的mapping属性包括：</p>
<ul>
<li>type：字段数据类型，常见的简单类型有：<ul>
<li>字符串：text(可分词文本)、keyword(精确值，例如：品牌、国家、IP地址)</li>
<li>数值：long、integer、short、byte、double、float</li>
<li>布尔：boolean</li>
<li>日期：date</li>
<li>对象：object</li>
</ul>
</li>
<li>index：是否创建索引，默认为true</li>
<li>analyzer：使用那种分词器</li>
<li>properties：该字段的子字段</li>
</ul>
<h4 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h4><p>es中通过restful请求操作索引库、文档。请求内容用DSL语句来表示。创建索引库和mapping的DSL语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /rose</span><br><span class="line">&#123;</span><br><span class="line">	&quot;mapping&quot;:&#123;</span><br><span class="line">		&quot;properties&quot;:&#123;</span><br><span class="line">			&quot;info&quot;:&#123;</span><br><span class="line">				&quot;tupe&quot;:&quot;text&quot;,</span><br><span class="line">				&quot;analyzer&quot;:&quot;ik_smart&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;email&quot;:&#123;</span><br><span class="line">				&quot;type&quot;:&quot;keyword&quot;,</span><br><span class="line">				&quot;index&quot;:&quot;false&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;name&quot;:&#123;</span><br><span class="line">				&quot;properties&quot;:&#123;</span><br><span class="line">					&quot;firstName&quot;:&#123;</span><br><span class="line">						&quot;type&quot;:&quot;keyword&quot;	</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h4><p>查看索引库语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /rose</span><br></pre></td></tr></table></figure>

<p>删除索引库的语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DELETE /索引库名</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>DELETE &#x2F;rose</p>
<p>修改索引库：</p>
<p>索引库和mapping一旦创建无法修改，但是可以添加新的字段，语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /索引库名/_mapping</span><br><span class="line">&#123;</span><br><span class="line">	&quot;properties&quot;:&#123;</span><br><span class="line">		&quot;新的字段名&quot;:&#123;</span><br><span class="line">			&quot;type&quot;:&quot;integer&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意新的字段一定是 原本不存在的</span></span><br></pre></td></tr></table></figure>

<h4 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h4><p>添加文档：  新增文档的DSL语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST</span><br><span class="line">&#123;</span><br><span class="line">	&quot;字段1&quot;:&quot;值1&quot;，</span><br><span class="line">	&quot;字段2&quot;:&quot;值2&quot;，</span><br><span class="line">	&quot;字段3&quot;:&#123;</span><br><span class="line">		&quot;子属性1&quot;:&quot;值3&quot;,</span><br><span class="line">		&quot;子属性2&quot;:&quot;值4&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询文档语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_doc/文档id</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /rose/_doc/1</span><br></pre></td></tr></table></figure>

<p>删除索引库的语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE /索引库名/_doc/文档id</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE /rose/——doc/</span><br></pre></td></tr></table></figure>

<p>修改文档：</p>
<p>方式一：全量修改，回删除旧文档，添加新文档。 既能更新也能添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT /索引库名/_doc/文档id</span><br><span class="line">&#123;</span><br><span class="line">	&quot;字段1&quot;:&quot;值1&quot;，</span><br><span class="line">	&quot;字段2&quot;:&quot;值2&quot;</span><br><span class="line">	//。。。略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：增量修改，修改指定字段值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_update/文档id</span><br><span class="line">&#123;</span><br><span class="line">	&quot;doc&quot;:&#123;</span><br><span class="line">    	&quot;字段名&quot;:&quot;新的值&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RestClient操作索引库"><a href="#RestClient操作索引库" class="headerlink" title="RestClient操作索引库"></a>RestClient操作索引库</h3><p>什么是RestClient？ </p>
<p>ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过gttp请求发送给es。</p>
<p>案例：利用JavaRestClient实现创建、删除索引库，判断索引库是否存在</p>
<p>根据课前资料提供的九点数据创建索引库，索引库名为hotel，mapping属性根据数据库结构定义。</p>
<p>基本步骤如下：</p>
<ol>
<li>导入课前资料Demo</li>
<li>分析数据结构，定义mapping属性</li>
<li>初始化JavaRestClient</li>
<li>利用JavaRestClient创建索引库</li>
<li>利用JavaRestClient删除索引库</li>
<li>利用JavaRestClient判断索引库是否存在</li>
</ol>
<h4 id="步骤二：数据分析"><a href="#步骤二：数据分析" class="headerlink" title="步骤二：数据分析"></a>步骤二：数据分析</h4><p>Es中支持两种地理坐标数据类型：</p>
<ul>
<li>geo_point:由维度和经度确定的一个点：”32.8752345,120.2981576”</li>
<li>geo_shape:有多个geo_point组成的复杂几何图形。例如一条直线”LINESTRING(-77.03653 38.897676,-77.009051 38.889939)”</li>
</ul>
<p>字段拷贝可以使用copy_to属性将当前字段拷贝到指定字段。示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&quot;all&quot;:&#123;</span><br><span class="line">	&quot;type&quot;:&quot;text&quot;,</span><br><span class="line">	&quot;analyzer&quot;:&quot;ik_max_word&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;brand&quot;&quot;&#123;</span><br><span class="line">	&quot;type&quot;:&quot;keyword&quot;,</span><br><span class="line">	&quot;copy_to&quot;:&quot;<span class="keyword">all</span>&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="步骤三：初始化RestClient"><a href="#步骤三：初始化RestClient" class="headerlink" title="步骤三：初始化RestClient"></a>步骤三：初始化RestClient</h4><ol>
<li><p>引入es的RestHighClient依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elaeticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>因为Springboot默认的es版本是7.6.2，所以我们需要覆盖默认的es版本：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化RestHighLevelClient：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">	<span class="built_in">this</span>.client = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(HttpHost.create(<span class="string">&quot;http:43.143.237.123:9200&quot;</span>)));</span><br><span class="line">))</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="步骤四：创建索引库"><a href="#步骤四：创建索引库" class="headerlink" title="步骤四：创建索引库"></a>步骤四：创建索引库</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testInit</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建Request对象</span></span><br><span class="line">        <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">        <span class="comment">//2、请求参数，MAPPING_TEMPLATE是静态常量字符串，内容是创建索引可的DSL语句</span></span><br><span class="line">        request.source(MAAPING_TEMPLATE, XContentType.JSON);</span><br><span class="line">        <span class="comment">//3、发起请求</span></span><br><span class="line">        client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="步骤五：删除索引库、判断索引库是否存在"><a href="#步骤五：删除索引库、判断索引库是否存在" class="headerlink" title="步骤五：删除索引库、判断索引库是否存在"></a>步骤五：删除索引库、判断索引库是否存在</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1、创建Request对象</span></span><br><span class="line">    <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">//3、发起请求</span></span><br><span class="line">    client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testExits</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1、创建Request对象</span></span><br><span class="line">    <span class="type">GetIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">//3、发起请求</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.err.println(exists?<span class="string">&quot;索引库存在&quot;</span>:<span class="string">&quot;索引库不存在&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RestClient操作文档"><a href="#RestClient操作文档" class="headerlink" title="RestClient操作文档"></a>RestClient操作文档</h3><p>案例：利用JavaRestClient实现文档的CRUD</p>
<p>去数据库查询酒店数据，导入到hotel索引库，实现酒店数据的CRUD。</p>
<p>基本步骤如下：</p>
<ol>
<li>初始化JavaRestClient</li>
<li>利用JavaRestClient新增酒店数据</li>
<li>利用JavaRestClient根据id查询酒店数据</li>
<li>利用JavaRestClient删除酒店数据</li>
<li>利用JavaRestClient修改酒店数据</li>
</ol>
<h4 id="步骤一：初始化"><a href="#步骤一：初始化" class="headerlink" title="步骤一：初始化"></a>步骤一：初始化</h4><p>新建一个测试类，实现文档相关操作，并且完成javarestClient的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDocumentTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.client = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(HttpHost.create(<span class="string">&quot;http://43.143.237.123:9200&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="步骤2：添加酒店数据到索引库"><a href="#步骤2：添加酒店数据到索引库" class="headerlink" title="步骤2：添加酒店数据到索引库"></a>步骤2：添加酒店数据到索引库</h4><p>先查询酒店数据，然后给这条数据创建倒排索引，即可完成添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> IHotelService iHotelService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//查询数据</span></span><br><span class="line">    <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> iHotelService.getById(<span class="number">36934L</span>);</span><br><span class="line">    <span class="comment">//转换为文档类型</span></span><br><span class="line">    HotelDoc hotelDoc=<span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);</span><br><span class="line">    <span class="comment">//1、准备request对象</span></span><br><span class="line">    <span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;hotel&quot;</span>).id(hotel.getId().toString());</span><br><span class="line">    <span class="comment">//2、准备json文档</span></span><br><span class="line">    indexRequest.source(JSON.toJSONString(hotelDoc), XContentType.JSON);</span><br><span class="line">    <span class="comment">//3、发送请求</span></span><br><span class="line">    client.index(indexRequest, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="步骤三：根据id查询酒店数据"><a href="#步骤三：根据id查询酒店数据" class="headerlink" title="步骤三：根据id查询酒店数据"></a>步骤三：根据id查询酒店数据</h4><p>根据id查询到的文档数据是json，需要反序列化为java对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">GetRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;hotel&quot;</span>).id(<span class="string">&quot;36934&quot;</span>);</span><br><span class="line">    <span class="type">GetResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> response.getSourceAsString();</span><br><span class="line">    <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">    System.out.println(hotelDoc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="步骤四：根据id修改酒店数据"><a href="#步骤四：根据id修改酒店数据" class="headerlink" title="步骤四：根据id修改酒店数据"></a>步骤四：根据id修改酒店数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1、创建request对象</span></span><br><span class="line">    <span class="type">UpdateRequest</span> <span class="variable">request</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;hotel&quot;</span>,<span class="string">&quot;36934&quot;</span>);</span><br><span class="line">    <span class="comment">//2、准备请求参数</span></span><br><span class="line">    request.doc(</span><br><span class="line">            <span class="string">&quot;price&quot;</span>,<span class="string">&quot;380&quot;</span>,</span><br><span class="line">            <span class="string">&quot;starName&quot;</span>,<span class="string">&quot;新二钻&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//3、发送请求</span></span><br><span class="line">    client.update(request,RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="步骤五：根据id删除酒店数据"><a href="#步骤五：根据id删除酒店数据" class="headerlink" title="步骤五：根据id删除酒店数据"></a>步骤五：根据id删除酒店数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1、创建request对象</span></span><br><span class="line">    <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;hotel&quot;</span>,<span class="string">&quot;36934&quot;</span>);</span><br><span class="line">    <span class="comment">//3、发送请求</span></span><br><span class="line">    client.delete(request,RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tip：批处理"><a href="#tip：批处理" class="headerlink" title="tip：批处理"></a>tip：批处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBulkDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//批量查询酒店数据</span></span><br><span class="line">    List&lt;Hotel&gt; list = iHotelService.list();</span><br><span class="line">    <span class="comment">//1、创建request对象</span></span><br><span class="line">    <span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">    <span class="comment">//2、准备参数</span></span><br><span class="line">    <span class="keyword">for</span> (Hotel hotel : list) &#123;</span><br><span class="line">        HotelDoc hotelDoc=<span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);</span><br><span class="line">        request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;hotel&quot;</span>).id(</span><br><span class="line">                hotelDoc.getId().toString())</span><br><span class="line">                .source(JSON.toJSONString(hotelDoc),XContentType.JSON)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、发送请求</span></span><br><span class="line">    client.bulk(request,RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DSL查询语法"><a href="#DSL查询语法" class="headerlink" title="DSL查询语法"></a>DSL查询语法</h3><h4 id="DSLQuery的分类"><a href="#DSLQuery的分类" class="headerlink" title="DSLQuery的分类"></a>DSLQuery的分类</h4><p>Elasticsearch提供了基于json的dsl来定义查询。常见的查询类型包括：</p>
<ul>
<li>查询所有：查询出所有数据，一般测试用。例如：match_all</li>
<li>全文检索（full text）查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：<ul>
<li>match_query</li>
<li>multi_match_query</li>
</ul>
</li>
<li>精确查询：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型的字段。例如：<ul>
<li>ids</li>
<li>range</li>
<li>term</li>
</ul>
</li>
<li>地理（geo）查询：根据经纬度查询。例如：<ul>
<li>geo_distance</li>
<li>geo_bounding_box</li>
</ul>
</li>
<li>复合（compound）查询：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：<ul>
<li>bool</li>
<li>function_score</li>
</ul>
</li>
</ul>
<h4 id="DSL-Query基本语法"><a href="#DSL-Query基本语法" class="headerlink" title="DSL Query基本语法"></a>DSL Query基本语法</h4><p>​	查询的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>indexName<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">		&quot;查询类型&quot;:&#123;</span><br><span class="line">			&quot;查询条件&quot;:&quot;条件值&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询所有</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>indexName<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">		&quot;match_all&quot;:&#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="全文检索查询"><a href="#全文检索查询" class="headerlink" title="全文检索查询"></a>全文检索查询</h4><p>全文检索查询，会对用户输入内容分词，常用于搜索框搜索：</p>
<p>matcha查询：全文检索查询的一种，会对用户输入的内容进行分词，然后去倒排索引库检索，语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>indexName<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">		&quot;match&quot;:&#123;</span><br><span class="line">			&quot;FIELD&quot;:&quot;TEXT&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>multi_match：与match查询相似，只不过允许同时查询多个字段，语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>indexName<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">		&quot;multi_match&quot;:&#123;</span><br><span class="line">			&quot;query&quot;:&quot;TEXT&quot;,</span><br><span class="line">			&quot;fields&quot;:[&quot;Field1&quot;,&quot;Field2&quot;]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h4><p>精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以不会对搜索条件分词。常见的有：</p>
<ul>
<li>term：根据词条精确值查询</li>
<li>range：根据值的范围查询</li>
</ul>
<p>语法如下：</p>
<p>term:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>hotel<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;city&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;上海&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>range：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#精确查询 <span class="keyword">range</span></span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>hotel<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: <span class="number">335</span>,</span><br><span class="line">        &quot;lte&quot;: <span class="number">337</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="地理查询"><a href="#地理查询" class="headerlink" title="地理查询"></a>地理查询</h4><p>根据经纬度查询。常见的使用场景：</p>
<ul>
<li>携程：搜索我附近的酒店</li>
<li>滴滴：搜索我附近的出租车</li>
</ul>
<p>根据经纬度查询，官方文档。例如：</p>
<ul>
<li><p>geo_bounding_box：查询geo_point值落在某个举行范围的所有文档</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>indexName<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">		&quot;geo_bounding_box&quot;:&#123;</span><br><span class="line">			&quot;FIELD&quot;:&#123;</span><br><span class="line">				&quot;top_left&quot;:&#123;</span><br><span class="line">                	&quot;lat&quot;:<span class="number">31.1</span>,</span><br><span class="line">                	&quot;lon&quot;:<span class="number">121.5</span></span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;bottom_right&quot;:&#123;</span><br><span class="line">					&quot;lat&quot;:<span class="number">30.9</span>,</span><br><span class="line">					&quot;lon&quot;:<span class="number">121.7</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>geo_distance：查询到指定中心点小于莫格距离值的所有文档</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>indexName<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">		&quot;geo_distance&quot;:&#123;</span><br><span class="line">			&quot;distance&quot;:&quot;15km&quot;,</span><br><span class="line">			&quot;FIELD&quot;:&quot;31.21,121.5&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h4><p>复合查询：复合查询可以将其他简单查询组合起来，实现更复杂的搜索逻辑，例如：</p>
<ul>
<li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名。例如百度竞价</li>
</ul>
<p>相关性算分</p>
<p>当我们利用match查询时，文档结果回根据与搜索词条的关联度打分，返回结果时按照分值降序排列。</p>
<ul>
<li>TF（词条频率）&#x3D;词条出现次数 &#x2F; 文档中词条总数</li>
<li>TF—IDF算法：<ul>
<li>IDF（逆文档频率）&#x3D;log(文档总数 &#x2F; 包含词条的文档总数)</li>
<li>score&#x3D;∑TF词条频率 * IDF（逆文档频率）</li>
</ul>
</li>
<li>BM25算法（主流）</li>
</ul>
<h4 id="FunctionScoreQuery"><a href="#FunctionScoreQuery" class="headerlink" title="FunctionScoreQuery"></a>FunctionScoreQuery</h4><p>使用FunctionScoreQuery，可以修改文档的相关性算分，根据新的到的算分排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>hotel<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;all&quot;: &quot;上海&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;id&quot;: &quot;5873072&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;boost_mode&quot;: &quot;multiply&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>“query”:{“match”:{“all”:”外滩”}}：原始查询条件，搜索文档并根据相关性打分(query score)</li>
<li>“filter”:{“term”:{“id”:”1”}}            过滤条件，符合条件的文档才会背重新算分</li>
<li>“weight”:10         算分函数，算分函数结果称为function score ，将来回与query score运算得到新算分，常见算分函数有：<ul>
<li>weight：给一个常量值，作为函数结果</li>
<li>field_value_factor：用文档中的某个字段值作为函数结果</li>
<li>random_score：随机生成一个值，作为函数结果</li>
<li>script_score：自定义计算公式，公式结果作为函数结果</li>
</ul>
</li>
<li>“boost_mode”:”multiply”         加权模式，定义function score与query score的运算方式，包括：<ul>
<li>multiply：两者相乘。默认就是这个</li>
<li>replace：用function score 替换query score</li>
<li>其他：sum、avg、max、min</li>
</ul>
</li>
</ul>
<h4 id="BooleanQuery"><a href="#BooleanQuery" class="headerlink" title="BooleanQuery"></a>BooleanQuery</h4><p>布尔查询是一个或多个查询字句的组合，子查询的组合方式有：</p>
<ul>
<li>must：必须匹配每个子查询，类似”与”</li>
<li>should：选择性匹配子查询，类似”或”</li>
<li>must_not：必须不匹配，不参与算分，类似”非”</li>
<li>filter：必须匹配，不参与算分</li>
</ul>
<p>案例：利用bool查询实现功能：</p>
<p>需求：搜索名字包含如家，价格不高于400，在坐标31.21，121.5周围10km范围内的酒店。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#复合查询  BooleanQuery</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>hotel<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;如家&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;range&quot;: &#123;</span><br><span class="line">            &quot;score&quot;: &#123;</span><br><span class="line">              &quot;gt&quot;: <span class="number">400</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;geo_distance&quot;: &#123;</span><br><span class="line">            &quot;distance&quot;: &quot;10km&quot;,</span><br><span class="line">            &quot;location&quot;: &#123;</span><br><span class="line">              &quot;lat&quot;: <span class="number">31.21</span>,</span><br><span class="line">              &quot;lon&quot;: <span class="number">121.5</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="搜索结果处理"><a href="#搜索结果处理" class="headerlink" title="搜索结果处理"></a>搜索结果处理</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>elasticsearch支持对搜索结果排序，默认是根据相关度算分来排序。可以排序的字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 排序  标准</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>hotel<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;score&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;asc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 排序 地理坐标</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>hotel<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_geo_distance&quot;: &#123;</span><br><span class="line">        &quot;location&quot;: &#123;</span><br><span class="line">          &quot;lat&quot;: <span class="number">31.034661</span>,</span><br><span class="line">          &quot;lon&quot;: <span class="number">121.612282</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;order&quot;: &quot;asc&quot;,</span><br><span class="line">        &quot;unit&quot;: &quot;km&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>elasticsearch默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。</p>
<p>elastic search中通过修改from、size参数来控制要返回的分页结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#分页</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>hotel<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;from&quot;: <span class="number">0</span>,</span><br><span class="line">  &quot;size&quot;: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>深度分页问题</strong></p>
<p>ES是分布式的，所以回面临深度分页问题。例如按照price排序后，获取from&#x3D;990，size&#x3D;10的数据：</p>
<ol>
<li>首先在每个数据片上都排序并查询前1000条文档</li>
<li>然后将所有节点的结果聚合，在内存中重新排序选出前1000条文档</li>
<li>最后从这10000条中，选取从990开始的10条文档</li>
</ol>
<p>如果搜索页数过深，或者结果集（from+size）越大，对内存和cpu的消耗越高。因此es色号顶结果集查询上线是10000</p>
<p><strong>深度分页解决方案</strong></p>
<p><strong>针对深度分页，es提供了两种解决方案</strong></p>
<ul>
<li>search  after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐</li>
<li>scroll：原理将排序数据形成快照，保存在内存。官方不推荐</li>
</ul>
<h4 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h4><p>高亮：就是在搜索结果中把搜索关键字突出显示</p>
<p>原理：</p>
<ul>
<li>将搜索结果中的关键字用标签标记出来</li>
<li>在页面中给标签添加css样式</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#高亮</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>hotel<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;all&quot;: &quot;如家&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;require_field_match&quot;: &quot;false&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RestClient查询文档"><a href="#RestClient查询文档" class="headerlink" title="RestClient查询文档"></a>RestClient查询文档</h3><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>我们通过match_all来演示基本的api</p>
<p>RestAPI中其中构建DSL是通过HighLevelRestClient中的resource来实现的，其中包含了查询、排序、分页、高亮等所有功能。</p>
<p>RestAPI中其中构建条件的核心部分是由一个名为QueryBuilders的工具类提供的，其中包含了各种查询方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1、获取SearchRequest对象</span></span><br><span class="line">    SearchRequest request=<span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">//2、设置参数</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">//3、发请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4、处理结果集</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">hits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="type">TotalHits</span> <span class="variable">totalHits</span> <span class="operator">=</span> hits.getTotalHits();</span><br><span class="line">    System.out.println(totalHits);</span><br><span class="line">    SearchHit[] searchHits = hits.getHits();</span><br><span class="line">    <span class="comment">//5.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit searchHit : searchHits) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> searchHit.getSourceAsString();</span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(source, HotelDoc.class);</span><br><span class="line">        System.out.println(hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="全文检索查询-1"><a href="#全文检索查询-1" class="headerlink" title="全文检索查询"></a>全文检索查询</h4><p>match</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1、获取SearchRequest对象</span></span><br><span class="line">    SearchRequest request=<span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">//2、设置参数</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;如家&quot;</span>));</span><br><span class="line">    <span class="comment">//3、发请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    handlerResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>boolean: term、range</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Test</span></span><br><span class="line">void testBool() throws IOException &#123;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="number">1</span>、获取SearchRequest对象</span><br><span class="line">    SearchRequest request<span class="operator">=</span><span class="keyword">new</span> SearchRequest(&quot;hotel&quot;);</span><br><span class="line">    BoolQueryBuilder boolQuery <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="number">2</span>、设置dsl传语句</span><br><span class="line">    boolQuery.must(QueryBuilders.termQuery(&quot;city&quot;,&quot;北京&quot;));</span><br><span class="line">    boolQuery.mustNot(QueryBuilders.rangeQuery(&quot;price&quot;).gt(<span class="number">500</span>));</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="number">2</span>、设置参数</span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="number">3</span>、发请求</span><br><span class="line">    SearchResponse response <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    handlerResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="排序和分页"><a href="#排序和分页" class="headerlink" title="排序和分页"></a>排序和分页</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Test</span></span><br><span class="line">void testPageAndSort() throws IOException &#123;</span><br><span class="line">    <span class="type">int</span> page <span class="operator">=</span> <span class="number">2</span>,size <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="number">1</span>、获取SearchRequest对象</span><br><span class="line">    SearchRequest request<span class="operator">=</span><span class="keyword">new</span> SearchRequest(&quot;hotel&quot;);</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="number">2</span>、设置参数</span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    request.source().<span class="keyword">from</span>((page<span class="number">-1</span>) <span class="operator">*</span> size).size(size);</span><br><span class="line">    request.source().sort(&quot;price&quot;, SortOrder.ASC);</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="number">3</span>、发请求</span><br><span class="line">    SearchResponse response <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    handlerResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高亮-1"><a href="#高亮-1" class="headerlink" title="高亮"></a>高亮</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@<span class="title class_">Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testHighLight</span>() throws <span class="title class_">IOException</span> &#123;</span><br><span class="line">       <span class="comment">//1、获取SearchRequest对象</span></span><br><span class="line">       <span class="title class_">SearchRequest</span> request=<span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">       <span class="comment">//2、设置参数</span></span><br><span class="line">       request.<span class="title function_">source</span>().<span class="title function_">query</span>(<span class="title class_">QueryBuilders</span>.<span class="title function_">matchQuery</span>(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;北京&quot;</span>));</span><br><span class="line">       request.<span class="title function_">source</span>().<span class="title function_">highlighter</span>(<span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>().<span class="title function_">field</span>(<span class="string">&quot;name&quot;</span>).requireFieldMatch(<span class="literal">false</span>));</span><br><span class="line">       <span class="comment">//3、发请求</span></span><br><span class="line">       <span class="title class_">SearchResponse</span> response = client.<span class="title function_">search</span>(request, <span class="title class_">RequestOptions</span>.<span class="property">DEFAULT</span>);</span><br><span class="line">       <span class="title function_">handlerResponse</span>(response);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlerResponse</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//4、处理结果集</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">hits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="type">TotalHits</span> <span class="variable">totalHits</span> <span class="operator">=</span> hits.getTotalHits();</span><br><span class="line">    System.out.println(totalHits);</span><br><span class="line">    SearchHit[] searchHits = hits.getHits();</span><br><span class="line">    <span class="comment">//5.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit searchHit : searchHits) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> searchHit.getSourceAsString();</span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(source, HotelDoc.class);</span><br><span class="line">        Map&lt;String, HighlightField&gt; map = searchHit.getHighlightFields();</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(map))&#123;</span><br><span class="line">            <span class="type">HighlightField</span> <span class="variable">highlightField</span> <span class="operator">=</span> map.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (highlightField!= <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> highlightField.getFragments()[<span class="number">0</span>].string();</span><br><span class="line">                hotelDoc.setName(string);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h3><p>聚合的分类</p>
<p>聚合可以实现对文档数据的统计、分析、运算。聚合常见的有三大类：</p>
<ul>
<li>桶(Bucket)聚合：用来对文档做分组<ul>
<li>TermAggregation：按照文档字段值分组</li>
<li>DateHistogram：按照容器阶梯分组，例如一周为一组，或一月为一组</li>
</ul>
</li>
<li>度量(Metric)聚合：用以计算一些值，比如：最大值、最小值、平均值等<ul>
<li>AVG：求平均值</li>
<li>Max：求最大值</li>
<li>Min：求最小值</li>
<li>Stats：同时求max、min、avg、sum等</li>
</ul>
</li>
<li>管道(pipeline)聚合：其他聚合的结果为基础做聚合</li>
</ul>
<p>聚合字段类型必须是：keyword、数值、日期、布尔。</p>
<h4 id="DSL实现Bucket聚合"><a href="#DSL实现Bucket聚合" class="headerlink" title="DSL实现Bucket聚合"></a>DSL实现Bucket聚合</h4><p>现在我们要统计所有数据中的酒店品牌有几种，此时可以根据酒店品牌的名称做聚合。类型为term</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 聚合查询</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>hotel<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;lte&quot;: <span class="number">500</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: <span class="number">0</span>, </span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;brandAgg&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;brand&quot;,</span><br><span class="line">        &quot;size&quot;: <span class="number">20</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>聚合结果排序</p>
<p>默认情况下，bucket聚合会统计Bucket内的文档数量，记为_count，并且按照 _count降序来排序，我们可以修改结果排序方式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 聚合查询</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>hotel<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;lte&quot;: <span class="number">500</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: <span class="number">0</span>, </span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;brandAgg&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;brand&quot;,</span><br><span class="line">        &quot;size&quot;: <span class="number">20</span>,</span><br><span class="line">        &quot;order&quot;: &#123;</span><br><span class="line">          &quot;_count&quot;: &quot;desc&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认情况下，Bucket聚合是对索引库的所有文档做聚合，我们可以限定要做聚合的文档范围，只要添加query条件即可</p>
<h4 id="DSL实现Metrics聚合"><a href="#DSL实现Metrics聚合" class="headerlink" title="DSL实现Metrics聚合"></a>DSL实现Metrics聚合</h4><p>例如我们要求获取每个品牌的用户评分的min、max、avg等值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 数据聚合stats</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>hotel<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: <span class="number">0</span>, </span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;lte&quot;: <span class="number">1000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;brandAgg&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;brand&quot;,</span><br><span class="line">        &quot;size&quot;: <span class="number">10</span>,</span><br><span class="line">        &quot;order&quot;: &#123;</span><br><span class="line">          &quot;scoreAgg.avg&quot;: &quot;desc&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;scoreAgg&quot;: &#123;</span><br><span class="line">          &quot;stats&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;score&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="RestClient实现聚合"><a href="#RestClient实现聚合" class="headerlink" title="RestClient实现聚合"></a>RestClient实现聚合</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Test</span></span><br><span class="line">void testAggregation() throws IOException &#123;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="number">1</span>、获取SearchRequest对象</span><br><span class="line">    SearchRequest request <span class="operator">=</span> <span class="keyword">new</span> SearchRequest(&quot;hotel&quot;);</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="number">2</span>、设置参数</span><br><span class="line">    request.source().size(<span class="number">0</span>);</span><br><span class="line">    request.source().aggregation(AggregationBuilders.terms(&quot;branAgg&quot;).field(&quot;brand&quot;).size(<span class="number">5</span>));</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="number">3</span>、发请求</span><br><span class="line">    SearchResponse response <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    Aggregations aggregations <span class="operator">=</span> response.getAggregations();</span><br><span class="line">    Terms brandTerms <span class="operator">=</span> aggregations.get(&quot;branAgg&quot;);</span><br><span class="line">    List<span class="operator">&lt;</span>? extends Terms.Bucket<span class="operator">&gt;</span> buckets <span class="operator">=</span> brandTerms.getBuckets();</span><br><span class="line">    <span class="keyword">for</span> (Terms.Bucket bucket : buckets) &#123;</span><br><span class="line">        String key <span class="operator">=</span> bucket.getKeyAsString();</span><br><span class="line">        System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><h4 id="拼音分词器"><a href="#拼音分词器" class="headerlink" title="拼音分词器"></a>拼音分词器</h4><p>要实现根据字母做补全，就必须对文档按照拼音分词。在github上恰好有elasticsearch的拼音分词插件。</p>
<p>elasticsearch中分词器的组成包含三个部分：</p>
<ul>
<li>character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符</li>
<li>tokenizer：将文本按照一定的规则切割成词条，例如keyword、就是不分词；还有ik_smart</li>
<li>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</li>
</ul>
<h4 id="自定义分词器"><a href="#自定义分词器" class="headerlink" title="自定义分词器"></a>自定义分词器</h4><p>我们可以在创建索引库时，通过settings来配置自定义的analyzer（分词器）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">put <span class="operator">/</span>test</span><br><span class="line">&#123;</span><br><span class="line">	&quot;settings&quot;:&#123;</span><br><span class="line">		&quot;analysis&quot;:&#123;</span><br><span class="line">			&quot;analyzer&quot;:&#123;#自定义分词器</span><br><span class="line">				&quot;my_analyzer&quot;:&#123; #自定义的分词器名</span><br><span class="line">					&quot;tokenizer&quot;:&quot;ik_max_word&quot;,</span><br><span class="line">					&quot;filter&quot;:&quot;pinyin&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 自定义拼音分词器</span><br><span class="line">PUT <span class="operator">/</span>test</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;analysis&quot;: &#123;</span><br><span class="line">      &quot;analyzer&quot;: &#123; </span><br><span class="line">        &quot;my_analyzer&quot;: &#123; </span><br><span class="line">          &quot;tokenizer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">          &quot;filter&quot;: &quot;py&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;py&quot;: &#123; </span><br><span class="line">          &quot;type&quot;: &quot;pinyin&quot;,</span><br><span class="line">          &quot;keep_full_pinyin&quot;: <span class="literal">false</span>,</span><br><span class="line">          &quot;keep_joined_full_pinyin&quot;: <span class="literal">true</span>,</span><br><span class="line">          &quot;keep_original&quot;: <span class="literal">true</span>,</span><br><span class="line">          &quot;limit_first_letter_length&quot;: <span class="number">16</span>,</span><br><span class="line">          &quot;remove_duplicated_term&quot;: <span class="literal">true</span>,</span><br><span class="line">          &quot;none_chinese_pinyin_tokenize&quot;: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自定义分词器适合在创建倒排索引的时候使用，但不能再搜索的时候使用。</p>
<p>因此字段在创建倒排索引时应该用my_analyzer分词器；在搜索时应使用ik_smart分词器</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 自定义拼音分词器</span><br><span class="line">PUT <span class="operator">/</span>test</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;analysis&quot;: &#123;</span><br><span class="line">      &quot;analyzer&quot;: &#123; </span><br><span class="line">        &quot;my_analyzer&quot;: &#123; </span><br><span class="line">          &quot;tokenizer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">          &quot;filter&quot;: &quot;py&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;py&quot;: &#123; </span><br><span class="line">          &quot;type&quot;: &quot;pinyin&quot;,</span><br><span class="line">          &quot;keep_full_pinyin&quot;: <span class="literal">false</span>,</span><br><span class="line">          &quot;keep_joined_full_pinyin&quot;: <span class="literal">true</span>,</span><br><span class="line">          &quot;keep_original&quot;: <span class="literal">true</span>,</span><br><span class="line">          &quot;limit_first_letter_length&quot;: <span class="number">16</span>,</span><br><span class="line">          &quot;remove_duplicated_term&quot;: <span class="literal">true</span>,</span><br><span class="line">          &quot;none_chinese_pinyin_tokenize&quot;: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;mappngs&quot;:&#123;</span><br><span class="line">      	&quot;properties&quot;:&#123;</span><br><span class="line">      		&quot;name&quot;:&#123;</span><br><span class="line">      			&quot;type&quot;:&quot;text&quot;,</span><br><span class="line">      			&quot;analyzer&quot;:&quot;my_analyzer&quot;,</span><br><span class="line">      			&quot;search_analyzer&quot;:&quot;ik_smart&quot;</span><br><span class="line">      		&#125;</span><br><span class="line">      	&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="completion-suggester查询"><a href="#completion-suggester查询" class="headerlink" title="completion suggester查询"></a>completion suggester查询</h4><p>elasticsearch提供了Completion suggester查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询效率，对于文档中字段的类型有一些约束：</p>
<ul>
<li><p>参与补全查询的字段必须是completion类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">put test</span><br><span class="line">&#123;</span><br><span class="line">	&quot;mappings&quot;:&#123;</span><br><span class="line">		&quot;properties&quot;:&#123;</span><br><span class="line">			&quot;title&quot;:&#123;</span><br><span class="line">				&quot;type&quot;:&quot;completion&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>字段的内容一般是用来补全的多个词条形成的数组</p>
</li>
</ul>
<p>查询语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;suggest&quot;:&#123;</span><br><span class="line">		&quot;title_seggest&quot;:&#123;</span><br><span class="line">			&quot;text&quot;:&quot;s&quot;, #关键字</span><br><span class="line">			&quot;completion&quot;:&#123;</span><br><span class="line">				&quot;field&quot;:&quot;title&quot;, #补全查询的字段</span><br><span class="line">				&quot;skip_duplicates&quot;:&quot;true&quot;, #跳过重复的</span><br><span class="line">				&quot;size&quot;:<span class="number">10</span> #获取前十条数据</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RestApi实现自动补全"><a href="#RestApi实现自动补全" class="headerlink" title="RestApi实现自动补全"></a>RestApi实现自动补全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSuggest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1、获取SearchRequest对象</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">//2、设置参数</span></span><br><span class="line">    request.source().suggest(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SuggestBuilder</span>().addSuggestion(</span><br><span class="line">                    <span class="string">&quot;my_suggest&quot;</span>,</span><br><span class="line">                    SuggestBuilders.completionSuggestion(<span class="string">&quot;suggestion&quot;</span>)</span><br><span class="line">                            .prefix(<span class="string">&quot;s&quot;</span>)</span><br><span class="line">                            .skipDuplicates(<span class="literal">true</span>)</span><br><span class="line">                            .size(<span class="number">10</span>)</span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//3、发请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="type">Suggest</span> <span class="variable">suggest</span> <span class="operator">=</span> response.getSuggest();</span><br><span class="line">    <span class="type">CompletionSuggestion</span> <span class="variable">my_suggest</span> <span class="operator">=</span> suggest.getSuggestion(<span class="string">&quot;my_suggest&quot;</span>);</span><br><span class="line">    List&lt;CompletionSuggestion.Entry.Option&gt; options = my_suggest.getOptions();</span><br><span class="line">    <span class="keyword">for</span> (CompletionSuggestion.Entry.Option option : options) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> option.getText().string();</span><br><span class="line">        System.out.println(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数据同步-重要"><a href="#数据同步-重要" class="headerlink" title="数据同步(重要)"></a><strong>数据同步</strong>(重要)</h3><p>Elasticsearch中的酒店数据来自于mysql数据库，因此，mysql数据库发生改变时，elasticsearch也必须跟着改变，这个就时elasticsearch与mysql之间的数据同步。</p>
<h4 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h4><p>当酒店管理服务操作mysql数据库时，调用酒店搜索服务暴露的接口来修改Es</p>
<h4 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h4><p>使用mq中间件来实现，当酒店管理服务操作mysql数据库时，利用MQ通知酒店搜索服务，让酒店搜索服务更新ES</p>
<h4 id="监听binlog"><a href="#监听binlog" class="headerlink" title="监听binlog"></a>监听binlog</h4><p>使用mysql的binlog来实现，当酒店管理服务操作mysql数据库时，利用canal来监听mysql的binlog，当binlog改变就通知酒店搜索服务数据变更，酒店搜索服务来更新ES</p>
<p>总结：</p>
<ol>
<li>同步调用<ul>
<li>优点：实现简单，粗暴</li>
<li>缺点：业务耦合度高</li>
</ul>
</li>
<li>异步通知<ul>
<li>优点：低耦合，实现难度一般</li>
<li>缺点：依赖mq的高可靠性</li>
</ul>
</li>
<li>监听binlog<ul>
<li>优点：完全解除服务间耦合</li>
<li>缺点：开启binlog增加数据库负担、实现复杂度高</li>
</ul>
</li>
</ol>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>利用MQ实现mysql与es数据同步</p>
<p>步骤：</p>
<ul>
<li>导入课前资料提供的hotel-admin项目，启动并测试酒店数据的CRUD</li>
<li>声明exchange、queue、RoutingKey</li>
<li>在hote-admin中的增、删、改业务中完成消息发送</li>
<li>在hotel-demo中完成消息监听，并更新elasticsearch中数据</li>
<li>启动并测试数据同步功能</li>
</ul>
<h5 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h5><p>声明exchange、queue、RoutingKey</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TopicExchange <span class="title function_">topicExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(HotelMqConstants.EXCHANGE_NAME,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入和修改队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">insertQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(HotelMqConstants.INSERT_QUEUE_NAME,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入和修改队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">deleteQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(HotelMqConstants.DELETE_QUEUE_NAME,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入与修改绑定关系</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">insertBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(insertQueue()).to(topicExchange()).with(HotelMqConstants.INSERT_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除绑定关系</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">deleteBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(HotelMqConstants.DELETE_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveHotel</span><span class="params">(<span class="meta">@RequestBody</span> Hotel hotel)</span>&#123;</span><br><span class="line">    <span class="comment">// 新增酒店</span></span><br><span class="line">    hotelService.save(hotel);</span><br><span class="line">    <span class="comment">// 发送MQ消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(HotelMqConstants.EXCHANGE_NAME, HotelMqConstants.INSERT_KEY, hotel.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听插入和修改</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = HotelMqConstants.INSERT_QUEUE_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenHotelInsertOrUpdate</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    iHotelService.insertById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = HotelMqConstants.DELETE_QUEUE_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenHotelDelete</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    iHotelService.deleteById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ES集群"><a href="#ES集群" class="headerlink" title="ES集群"></a>ES集群</h3><p>单机的es做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。</p>
<ul>
<li>海量数据存储问题：将索引库从逻辑上拆分为N个分片，存储到多个节点</li>
<li>单点故障问题：将分片数据在不同节点做备份</li>
</ul>
<h4 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h4><p>docker-compose</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version: &#x27;2.2&#x27;</span><br><span class="line">services:</span><br><span class="line">  es01:</span><br><span class="line">    image: elasticsearch:7.12.1</span><br><span class="line">    container_name: es01 #容器名</span><br><span class="line">    environment:</span><br><span class="line">      - node.name=es01</span><br><span class="line">      - cluster.name=es-docker-cluster</span><br><span class="line">      - discovery.seed_hosts=es02,es03  #另外两个ip  docker内可以用名</span><br><span class="line">      - cluster.initial_master_nodes=es01,es02,es03 #主节点选举 </span><br><span class="line">      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - data01:/usr/share/elasticsearch/data</span><br><span class="line">    ports:</span><br><span class="line">      - 9200:9200</span><br><span class="line">    networks:</span><br><span class="line">      - elastic</span><br><span class="line">  es02:</span><br><span class="line">    image: elasticsearch:7.12.1</span><br><span class="line">    container_name: es02</span><br><span class="line">    environment:</span><br><span class="line">      - node.name=es02</span><br><span class="line">      - cluster.name=es-docker-cluster</span><br><span class="line">      - discovery.seed_hosts=es01,es03</span><br><span class="line">      - cluster.initial_master_nodes=es01,es02,es03</span><br><span class="line">      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - data02:/usr/share/elasticsearch/data</span><br><span class="line">    ports:</span><br><span class="line">      - 9201:9200</span><br><span class="line">    networks:</span><br><span class="line">      - elastic</span><br><span class="line">  es03:</span><br><span class="line">    image: elasticsearch:7.12.1</span><br><span class="line">    container_name: es03</span><br><span class="line">    environment:</span><br><span class="line">      - node.name=es03</span><br><span class="line">      - cluster.name=es-docker-cluster</span><br><span class="line">      - discovery.seed_hosts=es01,es02</span><br><span class="line">      - cluster.initial_master_nodes=es01,es02,es03</span><br><span class="line">      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - data03:/usr/share/elasticsearch/data</span><br><span class="line">    networks:</span><br><span class="line">      - elastic</span><br><span class="line">    ports:</span><br><span class="line">      - 9202:9200</span><br><span class="line">volumes:</span><br><span class="line">  data01:</span><br><span class="line">    driver: local</span><br><span class="line">  data02:</span><br><span class="line">    driver: local</span><br><span class="line">  data03:</span><br><span class="line">    driver: local</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  elastic:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure>

<p>es运行还需要修改一些linux的系统权限，修改&#x2F;etc&#x2F;sysctl.conf文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加下面内容</span></span><br><span class="line">vm.max_map_count=262144</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后执行命令，让配置生效</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h4 id="集群状态监控"><a href="#集群状态监控" class="headerlink" title="集群状态监控"></a>集群状态监控</h4><p>kibana监控不好用，用cerebro来监控集群状态，解压后直接用</p>
<p>创建索引库</p>
<ol>
<li><p>利用kibana的devtools创建索引库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">put <span class="operator">/</span>rose</span><br><span class="line">&#123;</span><br><span class="line">	&quot;settings&quot;:&#123;</span><br><span class="line">		&quot;number_of_shards&quot;:<span class="number">3</span>, #分片数量</span><br><span class="line">		&quot;number_of_replicas&quot;:<span class="number">1</span>  #副本数量</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;mappings&quot;:&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="ES集群职责和脑裂"><a href="#ES集群职责和脑裂" class="headerlink" title="ES集群职责和脑裂"></a>ES集群职责和脑裂</h4><table>
<thead>
<tr>
<th>节点类型</th>
<th>配置参数</th>
<th>默认值</th>
<th>节点职责</th>
</tr>
</thead>
<tbody><tr>
<td>master eligible</td>
<td>node.master</td>
<td>true</td>
<td>备选主节点：主节点可以管理和记录集群状态、决定分片在那个节点、处理创建和删除索引库的请求</td>
</tr>
<tr>
<td>data</td>
<td>node.data</td>
<td>true</td>
<td>数据节点：存储数据、搜索、聚合、CRUD</td>
</tr>
<tr>
<td>ingest</td>
<td>node.ingest</td>
<td>true</td>
<td>数据存储之前的预处理</td>
</tr>
<tr>
<td>coordingting</td>
<td>上面三个都为false，则为coordingnating节点</td>
<td>五</td>
<td>路由请求到其他节点，合并其他节点处理的结果，返回给用户</td>
</tr>
</tbody></table>
<p>es中的每个节点角色都有自己不同的职责，因此建议集群部署时，每个节点都有独立的角色。</p>
<h5 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h5><p>默认情况下，每个节点都是master eligible节点，因此一旦master节点宕机，其他候选节点会选举一个称为新的主节点。当主节点与其他节点网络故障时，可能发生脑裂问题。</p>
<p>为了避免脑裂问题，需要要求选票超过(eligible节点数量+1)&#x2F;2才能当选为主节点，因此eligible节点数量最好是奇数。对应配置项时discover.zen.minimum_master_nodes，在es7之后，已经成为默认配置，因此一般不会发生脑裂问题。</p>
<h4 id="ES集群的分布式存储"><a href="#ES集群的分布式存储" class="headerlink" title="ES集群的分布式存储"></a>ES集群的分布式存储</h4><p>当心怎文档时，应该保存到不同分片，保证数据均衡，那么coordingnating node如何确定数据改存储到那个分片呢？</p>
<p>Es会通过hash算法来计算文档应该存储到那个分片：</p>
<p>​					shard &#x3D; hash(_routing) % number_of_shards</p>
<p>说明：</p>
<ul>
<li>_routing默认是文档的id</li>
<li>number_of_shards分片数量</li>
</ul>
<p><strong>算法与分片数量有关，因此索引库一旦创建，分片数量不能修改</strong></p>
<p>ES的查询分成两个阶段：</p>
<ul>
<li>scatter phase：分散阶段，coordinating node会把请求分到每一个分片</li>
<li>gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户</li>
</ul>
<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>集群的master节点回监控集群中节点状态，如果发现有节点宕机，回立刻将宕机节点的分片数据迁移到其他节点，确保数据安全，这个叫做故障转移</p>
<h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><h3 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h3><p>微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩。</p>
<p><strong>解决雪崩问题的常见方式有四种：</strong></p>
<ul>
<li>超时处理：设定超时时间，请求超时一定时间没有响应就返回错误消息，不会无休止等待。</li>
<li>舱壁模式：限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，因此也叫线程隔离。</li>
<li>熔断降级：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，来接访问该业务的一切请求。</li>
<li>流量控制：限制业务访问的QPS，避免服务因流量的徒增而故障</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>TencentSMS</title>
    <url>/2023/05/28/14-22-46/</url>
    <content><![CDATA[<h1 id="腾讯云短信服务"><a href="#腾讯云短信服务" class="headerlink" title="腾讯云短信服务"></a>腾讯云短信服务</h1><span id="more"></span>

<ol>
<li><p>maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.tencentcloudapi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tencentcloud-sdk-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>发送验证码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSms</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/* 必要步骤：</span></span><br><span class="line"><span class="comment">             * 实例化一个认证对象，入参需要传入腾讯云账户密钥对secretId，secretKey。</span></span><br><span class="line"><span class="comment">             * 这里采用的是从环境变量读取的方式，需要在环境变量中先设置这两个值。</span></span><br><span class="line"><span class="comment">             * 你也可以直接在代码中写死密钥对，但是小心不要将代码复制、上传或者分享给他人，</span></span><br><span class="line"><span class="comment">             * 以免泄露密钥对危及你的财产安全。</span></span><br><span class="line"><span class="comment">             * SecretId、SecretKey 查询: https://console.cloud.tencent.com/cam/capi */</span></span><br><span class="line">            <span class="type">Credential</span> <span class="variable">cred</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Credential</span>(secretId, secretKey);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 实例化一个http选项，可选，没有特殊需求可以跳过</span></span><br><span class="line">            <span class="type">HttpProfile</span> <span class="variable">httpProfile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpProfile</span>();</span><br><span class="line">            <span class="comment">// 设置代理（无需要直接忽略）</span></span><br><span class="line">            <span class="comment">// httpProfile.setProxyHost(&quot;真实代理ip&quot;);</span></span><br><span class="line">            <span class="comment">// httpProfile.setProxyPort(真实代理端口);</span></span><br><span class="line">            <span class="comment">/* SDK默认使用POST方法。</span></span><br><span class="line"><span class="comment">             * 如果你一定要使用GET方法，可以在这里设置。GET方法无法处理一些较大的请求 */</span></span><br><span class="line">            httpProfile.setReqMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">            <span class="comment">/* SDK有默认的超时时间，非必要请不要进行调整</span></span><br><span class="line"><span class="comment">             * 如有需要请在代码中查阅以获取最新的默认值 */</span></span><br><span class="line">            httpProfile.setConnTimeout(<span class="number">60</span>);</span><br><span class="line">            <span class="comment">/* 指定接入地域域名，默认就近地域接入域名为 sms.tencentcloudapi.com ，也支持指定地域域名访问，例如广州地域的域名为 sms.ap-guangzhou.tencentcloudapi.com */</span></span><br><span class="line">            httpProfile.setEndpoint(<span class="string">&quot;sms.tencentcloudapi.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 非必要步骤:</span></span><br><span class="line"><span class="comment">             * 实例化一个客户端配置对象，可以指定超时时间等配置 */</span></span><br><span class="line">            <span class="type">ClientProfile</span> <span class="variable">clientProfile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientProfile</span>();</span><br><span class="line">            <span class="comment">/* SDK默认用TC3-HMAC-SHA256进行签名</span></span><br><span class="line"><span class="comment">             * 非必要请不要修改这个字段 */</span></span><br><span class="line">            clientProfile.setSignMethod(<span class="string">&quot;HmacSHA256&quot;</span>);</span><br><span class="line">            clientProfile.setHttpProfile(httpProfile);</span><br><span class="line">            <span class="comment">/* 实例化要请求产品(以sms为例)的client对象</span></span><br><span class="line"><span class="comment">             * 第二个参数是地域信息，可以直接填写字符串ap-guangzhou，支持的地域列表参考 https://cloud.tencent.com/document/api/382/52071#.E5.9C.B0.E5.9F.9F.E5.88.97.E8.A1.A8 */</span></span><br><span class="line">            <span class="type">SmsClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsClient</span>(cred, <span class="string">&quot;ap-guangzhou&quot;</span>, clientProfile);</span><br><span class="line">            <span class="comment">/* 实例化一个请求对象，根据调用的接口和实际情况，可以进一步设置请求参数</span></span><br><span class="line"><span class="comment">             * 你可以直接查询SDK源码确定接口有哪些属性可以设置</span></span><br><span class="line"><span class="comment">             * 属性可能是基本类型，也可能引用了另一个数据结构</span></span><br><span class="line"><span class="comment">             * 推荐使用IDE进行开发，可以方便的跳转查阅各个接口和数据结构的文档说明 */</span></span><br><span class="line">            <span class="type">SendSmsRequest</span> <span class="variable">req</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendSmsRequest</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 填充请求参数,这里request对象的成员变量即对应接口的入参</span></span><br><span class="line"><span class="comment">             * 你可以通过官网接口文档或跳转到request对象的定义处查看请求参数的定义</span></span><br><span class="line"><span class="comment">             * 基本类型的设置:</span></span><br><span class="line"><span class="comment">             * 帮助链接：</span></span><br><span class="line"><span class="comment">             * 短信控制台: https://console.cloud.tencent.com/smsv2</span></span><br><span class="line"><span class="comment">             * 腾讯云短信小助手: https://cloud.tencent.com/document/product/382/3773#.E6.8A.80.E6.9C.AF.E4.BA.A4.E6.B5.81 */</span></span><br><span class="line">            <span class="comment">/* 短信应用ID: 短信SdkAppId在 [短信控制台] 添加应用后生成的实际SdkAppId，示例如1400006666 */</span></span><br><span class="line">            <span class="comment">// 应用 ID 可前往 [短信控制台](https://console.cloud.tencent.com/smsv2/app-manage) 查看</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sdkAppId</span> <span class="operator">=</span> <span class="string">&quot;1400811386&quot;</span>;</span><br><span class="line">            req.setSmsSdkAppid(sdkAppId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 短信签名内容: 使用 UTF-8 编码，必须填写已审核通过的签名 */</span></span><br><span class="line">            <span class="comment">// 签名信息可前往 [国内短信](https://console.cloud.tencent.com/smsv2/csms-sign) 或 [国际/港澳台短信](https://console.cloud.tencent.com/smsv2/isms-sign) 的签名管理查看</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">signName</span> <span class="operator">=</span> <span class="string">&quot;韶华不为少年留公众号&quot;</span>;</span><br><span class="line">            req.setSign(signName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 模板 ID: 必须填写已审核通过的模板 ID */</span></span><br><span class="line">            <span class="comment">// 模板 ID 可前往 [国内短信](https://console.cloud.tencent.com/smsv2/csms-template) 或 [国际/港澳台短信](https://console.cloud.tencent.com/smsv2/isms-template) 的正文模板管理查看</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">templateId</span> <span class="operator">=</span> <span class="string">&quot;1762054&quot;</span>;</span><br><span class="line">            req.setTemplateID(templateId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 模板参数: 模板参数的个数需要与 TemplateId 对应模板的变量个数保持一致，若无模板参数，则设置为空 */</span></span><br><span class="line">            String[] templateParamSet = &#123;RandomUtils.getFourBitRandom()&#125;;</span><br><span class="line">            req.setTemplateParamSet(templateParamSet);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 下发手机号码，采用 E.164 标准，+[国家或地区码][手机号]</span></span><br><span class="line"><span class="comment">             * 示例如：+8613711112222， 其中前面有一个+号 ，86为国家码，13711112222为手机号，最多不要超过200个手机号 */</span></span><br><span class="line">            String[] phoneNumberSet = &#123;<span class="string">&quot;+86&quot;</span> + phone&#125;;</span><br><span class="line">            req.setPhoneNumberSet(phoneNumberSet);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 用户的 session 内容（无需要可忽略）: 可以携带用户侧 ID 等上下文信息，server 会原样返回 */</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sessionContext</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            req.setSessionContext(sessionContext);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 短信码号扩展号（无需要可忽略）: 默认未开通，如需开通请联系 [腾讯云短信小助手] */</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">extendCode</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            req.setExtendCode(extendCode);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 国际/港澳台短信 SenderId（无需要可忽略）: 国内短信填空，默认未开通，如需开通请联系 [腾讯云短信小助手] */</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">senderid</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            req.setSenderId(senderid);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 通过 client 对象调用 SendSms 方法发起请求。注意请求方法名与请求对象是对应的</span></span><br><span class="line"><span class="comment">             * 返回的 res 是一个 SendSmsResponse 类的实例，与请求对象对应 */</span></span><br><span class="line">            <span class="type">SendSmsResponse</span> <span class="variable">res</span> <span class="operator">=</span> client.SendSms(req);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出json格式的字符串回包</span></span><br><span class="line">            System.out.println(SendSmsResponse.toJsonString(res));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 也可以取出单个值，你可以通过官网接口文档或跳转到response对象的定义处查看返回字段的定义</span></span><br><span class="line">            <span class="comment">// System.out.println(res.getRequestId());</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 当出现以下错误码时，快速解决方案参考</span></span><br><span class="line"><span class="comment">             * [FailedOperation.SignatureIncorrectOrUnapproved](https://cloud.tencent.com/document/product/382/9558#.E7.9F.AD.E4.BF.A1.E5.8F.91.E9.80.81.E6.8F.90.E7.A4.BA.EF.BC.9Afailedoperation.signatureincorrectorunapproved-.E5.A6.82.E4.BD.95.E5.A4.84.E7.90.86.EF.BC.9F)</span></span><br><span class="line"><span class="comment">             * [FailedOperation.TemplateIncorrectOrUnapproved](https://cloud.tencent.com/document/product/382/9558#.E7.9F.AD.E4.BF.A1.E5.8F.91.E9.80.81.E6.8F.90.E7.A4.BA.EF.BC.9Afailedoperation.templateincorrectorunapproved-.E5.A6.82.E4.BD.95.E5.A4.84.E7.90.86.EF.BC.9F)</span></span><br><span class="line"><span class="comment">             * [UnauthorizedOperation.SmsSdkAppIdVerifyFail](https://cloud.tencent.com/document/product/382/9558#.E7.9F.AD.E4.BF.A1.E5.8F.91.E9.80.81.E6.8F.90.E7.A4.BA.EF.BC.9Aunauthorizedoperation.smssdkappidverifyfail-.E5.A6.82.E4.BD.95.E5.A4.84.E7.90.86.EF.BC.9F)</span></span><br><span class="line"><span class="comment">             * [UnsupportedOperation.ContainDomesticAndInternationalPhoneNumber](https://cloud.tencent.com/document/product/382/9558#.E7.9F.AD.E4.BF.A1.E5.8F.91.E9.80.81.E6.8F.90.E7.A4.BA.EF.BC.9Aunsupportedoperation.containdomesticandinternationalphonenumber-.E5.A6.82.E4.BD.95.E5.A4.84.E7.90.86.EF.BC.9F)</span></span><br><span class="line"><span class="comment">             * 更多错误，可咨询[腾讯云助手](https://tccc.qcloud.com/web/im/index.html#/chat?webAppId=8fa15978f85cb41f7e2ea36920cb3ae1&amp;title=Sms)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (TencentCloudSDKException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>腾讯云</tag>
        <tag>短信服务</tag>
      </tags>
  </entry>
</search>
